= Developer Documentation
:imagesdir: ./assets
:toc:

This is the developer documentation for fabric8-auth. It is useful if you wish to contribute to the fabric8-auth project in some way.

== Source code

The latest source code for fabric8-auth can be found at GitHub link:https://github.com/fabric8-services/fabric8-auth[here].  The repository is configured to perform automatic, continual releases from the *master* branch any time a new pull request is merged.

== Issue Tracking

link:https://github.com/fabric8-services/fabric8-auth/issues[GitHub issues] are used for tracking the development of new features and service issues.

== Development workflow

Basically, all work done to the fabric8-auth code base must have a corresponding issue, whether it be a complex new feature, major or minor bug or simply correcting a typo in the code, readme file or documentation.  This allows the project team to carefully manage and audit the changes made to such a critical piece of the fabric8 platform.  If you wish to contribute any code or other changes to the project, here are the steps to follow:

. Pick an existing issue to work with (or create a new one)
. Fork the fabric8-auth repository to your own GitHub account
. Check out the forked repository in your development environment
. Create a new branch representing the issue you will work on (*git checkout -b ISSUE-XXX*)
. Make your changes, commit them to the issue branch
. Push the changes to your forked repository
. In Github, browse to the issue branch in your forked repository
. Create a pull request for your issue branch, making sure to clearly link the issue that the PR is for
. Update the issue with a link to the pull request

== Makefile targets

[width="90%",cols="20,70"]
|============================
|build                 |
Compiles sources into executable binary
|dev                   |
Same as build, however also starts up a Docker instance of the Postgres database and runs the auth service on the host.
|deploy-auth-openshift |
Starts a minishift instance and deploys the "latest" tagged versions of the fabric-auth service, plus a postgres database from the docker.io repository, exposing the service at http://minishift.local:31000.
|dev-db-openshift      |
Starts a minishift instance and deploys a postgres database to it, while building and running the fabric8-auth service on the host machine which then connects to the db on port 31001.
|dev-openshift         |
Starts a minishift instance and deploys a postgres database to it, then builds and deploys the fabric-auth service to minishift also, exposing the service at http://minishift.local:31000.
|clean-openshift       |
Removes the deployment from minishift, deleting the deployments and removing the project.
|docs                  |
Builds the documentation in the /docs directory.
|============================

== Service Accounts

Service accounts are used by other services to allow secure service-to-service interaction.  One example of this is the auth service's protection API, which requires a PAT (Protection API Token) in order for the resource servers to register newly created resources, and query the access rights for clients attempting to access resources that they don't own.

Service account configuration is expected to be found in */etc/fabric8/service-account-secrets.conf*, in JSON format.  Here's an example configuration:

[source,json]
{
    "accounts": [
        {
            "name":"fabric8-wit",
            "id":"5dec5fdb-09e3-4453-b73f-5c828832b28e",
            "secrets":["$2a$04$nI7z7Re4pbx.V5vwm14n5.velhB.nbMgxdZ0vSomWVxcct34zbH9e"]
        },
        {
            "name":"fabric8-tenant",
            "id":"c211f1bd-17a7-4f8c-9f80-0917d167889d",
            "secrets":["$2a$04$ynqM/syKMYowMIn5cyqHuevWnfzIQqtyY4m.61B02qltY5SOyGIOe", "$2a$04$sbC/AfW2c33hv8orGA.1D.LXa/.IY76VWhsfqxCVhrhFkDfL0/XGK"]
        },
        {
            "name":"fabric8-jenkins-idler",
            "id":"341c283f-0cd7-48a8-9281-4583aceb3617",
            "secrets":["$2a$04$hbGHAVKohpeDgHzafnLwdO4ZzhEn9ukVP/6CaOtf5o3Btp.r6tXTG"]
        }
    ]
}

At deployment time this configuration file is provided by the container, via a pre-configured secret (see the reference docs for details). The configuration file is loaded in */configuration/configuration.go* as part of the call to *NewConfigurationData*.

This method loads the service account configuration and stores it in the *ConfigurationData.sa* type variable.  

The path of the configuration file can be overridden by either setting a command line parameter (*serviceAccountConfig*) or setting an environment variable (*AUTH_SERVICE_ACCOUNT_CONFIG_FILE*) to point to a new file location (see the *main()* function in */main.go*).

__Authentication__

Service account authentication is handled by the `Exchange` function in `/controller/token.go`:

[source]
func (c *TokenController) Exchange(ctx *app.ExchangeTokenContext) error {

== Permission Checks

The *HasScope()* method provided by the permission service makes use of a complex SQL query in order to determine whether a user has a particular scope for a resource.  Besides checking for privileges assigned directly to the user, this query also takes into account:

* that the user may inherit the scope indirectly via their memberships in an organization, team or security group
* that the resource in question may have a parent resource (or other resource ancestry) of the same type to which the user has been granted privileges
* that there may be a role mapping, allowing a user that has been granted privileges to a resource of a different type somewhere in the resource ancestry to gain privileges for other resource types further down the hierarchy

It accepts three parameters; the user's identity ID, the resource ID and the name of the scope.

This section will describe the various parts of the permission query, providing a useful reference in case the SQL requires future maintenance.

To begin, let's examine the query at the highest level.  Essentially, it checks the `IDENTITY_ROLE` table for the existence of any records that match the criteria as described above.  It does this by setting conditions for the three columns; `identity_id`, `resource_id` and `role_id`, which can be seen as follows:

image::permission_has_scope_sql_1.png[]

The following sections will examine each of these sections in more detail.

=== Identity criteria

In section 1 of the query above, the condition limits the records returned to those with an `IDENTITY_ID` equal to the current user's, or to that of any organization, team or security group in which the current user is a member.

This is done by selecting a list of the corresponding `ID` values from the `identities` table, and matching the `identity_role.identity_id` value against these:

image::permission_has_scope_sql_2.png[]

1. The first condition is a direct check for the user's identity ID, to match any records for which the role has been assigned directly to the user.
2. The second condition includes the identity ID for any organization, team or security group in which the user is either directly or indirectly a member.  This is achieved by executing a recursive subquery in the `membership` table to "walk" up the user's membership hierarchy, and extract out all of the `member_of` values.

=== Resource criteria

The second condition of the query is used to select records for the specified resource.  Its criteria restricts records to those with either the exact same `resource_id` value as the resource parameter, or to an ancestor resource:

image::permission_has_scope_sql_3.png[]

The criteria does this by executing a recursive subquery on the resource hierarchy, using the resource table's `parent_resource_id` to walk up the hierarchy. The resulting list of resource IDs is used to restrict the `resource_id` column.

=== Role criteria

The third condition of the query is by far the most complex, and is used to 

image::permission_has_scope_sql_4.png[]