// Code generated by goagen v1.2.0, DO NOT EDIT.
//
// API "wit": Application User Types
//
// Command:
// $ goagen
// --design=github.com/fabric8-services/fabric8-wit/design
// --notool=true
// --out=$(GOPATH)/src/github.com/fabric8-services/fabric8-auth/wit
// --pkg=witservice
// --version=v1.2.0

package witservice

import (
	"github.com/goadesign/goa"
	uuid "github.com/goadesign/goa/uuid"
	"time"
	"unicode/utf8"
)

// JSONAPI store for the data of a Area. See also http://jsonapi.org/format/#document-resource-object
type area struct {
	Attributes *areaAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of area
	ID            *uuid.UUID     `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks  `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *areaRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string        `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the area type instance.
func (ut *area) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "areas") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"areas"}))
		}
	}
	return
}

// Publicize creates Area from area
func (ut *area) Publicize() *Area {
	var pub Area
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a Area. See also http://jsonapi.org/format/#document-resource-object
type Area struct {
	Attributes *AreaAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of area
	ID            *uuid.UUID     `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks  `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *AreaRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string         `form:"type" json:"type" xml:"type"`
}

// Validate validates the Area type instance.
func (ut *Area) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "areas") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"areas"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a Area. See also see http://jsonapi.org/format/#document-resource-object-attributes
type areaAttributes struct {
	// When the area was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The Area name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Path to the topmost parent
	ParentPath *string `form:"parent_path,omitempty" json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// Path to the topmost area specified by area names
	ParentPathResolved *string `form:"parent_path_resolved,omitempty" json:"parent_path_resolved,omitempty" xml:"parent_path_resolved,omitempty"`
	// When the area was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the areaAttributes type instance.
func (ut *areaAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// Publicize creates AreaAttributes from areaAttributes
func (ut *areaAttributes) Publicize() *AreaAttributes {
	var pub AreaAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.ParentPath != nil {
		pub.ParentPath = ut.ParentPath
	}
	if ut.ParentPathResolved != nil {
		pub.ParentPathResolved = ut.ParentPathResolved
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a Area. See also see http://jsonapi.org/format/#document-resource-object-attributes
type AreaAttributes struct {
	// When the area was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The Area name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Path to the topmost parent
	ParentPath *string `form:"parent_path,omitempty" json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// Path to the topmost area specified by area names
	ParentPathResolved *string `form:"parent_path_resolved,omitempty" json:"parent_path_resolved,omitempty" xml:"parent_path_resolved,omitempty"`
	// When the area was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the AreaAttributes type instance.
func (ut *AreaAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// areaRelations user type.
type areaRelations struct {
	// This defines the sub-areas present for this area
	Children *relationGeneric `form:"children,omitempty" json:"children,omitempty" xml:"children,omitempty"`
	// This defines the parents' hierarchy for areas
	Parent *relationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the workitems associated with the Area
	Workitems *relationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
}

// Publicize creates AreaRelations from areaRelations
func (ut *areaRelations) Publicize() *AreaRelations {
	var pub AreaRelations
	if ut.Children != nil {
		pub.Children = ut.Children.Publicize()
	}
	if ut.Parent != nil {
		pub.Parent = ut.Parent.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	if ut.Workitems != nil {
		pub.Workitems = ut.Workitems.Publicize()
	}
	return &pub
}

// AreaRelations user type.
type AreaRelations struct {
	// This defines the sub-areas present for this area
	Children *RelationGeneric `form:"children,omitempty" json:"children,omitempty" xml:"children,omitempty"`
	// This defines the parents' hierarchy for areas
	Parent *RelationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the workitems associated with the Area
	Workitems *RelationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
}

// backlogGenericLink user type.
type backlogGenericLink struct {
	Meta *backlogLinkMeta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Self *string          `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the backlogGenericLink type instance.
func (ut *backlogGenericLink) Validate() (err error) {
	if ut.Meta != nil {
		if err2 := ut.Meta.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates BacklogGenericLink from backlogGenericLink
func (ut *backlogGenericLink) Publicize() *BacklogGenericLink {
	var pub BacklogGenericLink
	if ut.Meta != nil {
		pub.Meta = ut.Meta.Publicize()
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// BacklogGenericLink user type.
type BacklogGenericLink struct {
	Meta *BacklogLinkMeta `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Self *string          `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// backlogLinkMeta user type.
type backlogLinkMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the backlogLinkMeta type instance.
func (ut *backlogLinkMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	return
}

// Publicize creates BacklogLinkMeta from backlogLinkMeta
func (ut *backlogLinkMeta) Publicize() *BacklogLinkMeta {
	var pub BacklogLinkMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// BacklogLinkMeta user type.
type BacklogLinkMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// baseTypeData user type.
type baseTypeData struct {
	// ID of the work item type
	ID   *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the baseTypeData type instance.
func (ut *baseTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemtypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemtypes"}))
		}
	}
	return
}

// Publicize creates BaseTypeData from baseTypeData
func (ut *baseTypeData) Publicize() *BaseTypeData {
	var pub BaseTypeData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// BaseTypeData user type.
type BaseTypeData struct {
	// ID of the work item type
	ID   uuid.UUID `form:"id" json:"id" xml:"id"`
	Type string    `form:"type" json:"type" xml:"type"`
}

// Validate validates the BaseTypeData type instance.
func (ut *BaseTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}

	if !(ut.Type == "workitemtypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemtypes"}))
	}
	return
}

// JSONAPI store for the data of a codebase.  See also http://jsonapi.org/format/#document-resource-object
type codebase struct {
	Attributes *codebaseAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of codebase
	ID            *uuid.UUID         `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *codebaseLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *codebaseRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string            `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the codebase type instance.
func (ut *codebase) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "codebases") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"codebases"}))
		}
	}
	return
}

// Publicize creates Codebase from codebase
func (ut *codebase) Publicize() *Codebase {
	var pub Codebase
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a codebase.  See also http://jsonapi.org/format/#document-resource-object
type Codebase struct {
	Attributes *CodebaseAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of codebase
	ID            *uuid.UUID         `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *CodebaseLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *CodebaseRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string             `form:"type" json:"type" xml:"type"`
}

// Validate validates the Codebase type instance.
func (ut *Codebase) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if !(ut.Type == "codebases") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"codebases"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a codebase. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type codebaseAttributes struct {
	// When the codebase was created
	CreatedAt *time.Time `form:"createdAt,omitempty" json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// The last used workspace name of the codebase
	LastUsedWorkspace *string `form:"last_used_workspace,omitempty" json:"last_used_workspace,omitempty" xml:"last_used_workspace,omitempty"`
	// The stack id of the codebase
	StackID *string `form:"stackId,omitempty" json:"stackId,omitempty" xml:"stackId,omitempty"`
	// The codebase type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The URL of the codebase
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
}

// Publicize creates CodebaseAttributes from codebaseAttributes
func (ut *codebaseAttributes) Publicize() *CodebaseAttributes {
	var pub CodebaseAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.LastUsedWorkspace != nil {
		pub.LastUsedWorkspace = ut.LastUsedWorkspace
	}
	if ut.StackID != nil {
		pub.StackID = ut.StackID
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a codebase. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type CodebaseAttributes struct {
	// When the codebase was created
	CreatedAt *time.Time `form:"createdAt,omitempty" json:"createdAt,omitempty" xml:"createdAt,omitempty"`
	// The last used workspace name of the codebase
	LastUsedWorkspace *string `form:"last_used_workspace,omitempty" json:"last_used_workspace,omitempty" xml:"last_used_workspace,omitempty"`
	// The stack id of the codebase
	StackID *string `form:"stackId,omitempty" json:"stackId,omitempty" xml:"stackId,omitempty"`
	// The codebase type
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The URL of the codebase
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
}

// codebaseLinks user type.
type codebaseLinks struct {
	Edit    *string                `form:"edit,omitempty" json:"edit,omitempty" xml:"edit,omitempty"`
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates CodebaseLinks from codebaseLinks
func (ut *codebaseLinks) Publicize() *CodebaseLinks {
	var pub CodebaseLinks
	if ut.Edit != nil {
		pub.Edit = ut.Edit
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// CodebaseLinks user type.
type CodebaseLinks struct {
	Edit    *string                `form:"edit,omitempty" json:"edit,omitempty" xml:"edit,omitempty"`
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// codebaseListMeta user type.
type codebaseListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the codebaseListMeta type instance.
func (ut *codebaseListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	return
}

// Publicize creates CodebaseListMeta from codebaseListMeta
func (ut *codebaseListMeta) Publicize() *CodebaseListMeta {
	var pub CodebaseListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// CodebaseListMeta user type.
type CodebaseListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// codebaseRelations user type.
type codebaseRelations struct {
	// This defines the owning space
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Publicize creates CodebaseRelations from codebaseRelations
func (ut *codebaseRelations) Publicize() *CodebaseRelations {
	var pub CodebaseRelations
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// CodebaseRelations user type.
type CodebaseRelations struct {
	// This defines the owning space
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// JSONAPI store for the data of a comment.  See also http://jsonapi.org/format/#document-resource-object
type comment struct {
	Attributes *commentAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of comment
	ID            *uuid.UUID        `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *commentRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string           `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the comment type instance.
func (ut *comment) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "comments") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"comments"}))
		}
	}
	return
}

// Publicize creates Comment from comment
func (ut *comment) Publicize() *Comment {
	var pub Comment
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a comment.  See also http://jsonapi.org/format/#document-resource-object
type Comment struct {
	Attributes *CommentAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of comment
	ID            *uuid.UUID        `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *CommentRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string            `form:"type" json:"type" xml:"type"`
}

// Validate validates the Comment type instance.
func (ut *Comment) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "comments") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"comments"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a comment. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type commentAttributes struct {
	// The comment body
	Body *string `form:"body,omitempty" json:"body,omitempty" xml:"body,omitempty"`
	// The comment body rendered in HTML
	BodyRendered *string `form:"body.rendered,omitempty" json:"body.rendered,omitempty" xml:"body.rendered,omitempty"`
	// When the comment was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The comment markup associated with the body
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
	// When the comment was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
}

// Publicize creates CommentAttributes from commentAttributes
func (ut *commentAttributes) Publicize() *CommentAttributes {
	var pub CommentAttributes
	if ut.Body != nil {
		pub.Body = ut.Body
	}
	if ut.BodyRendered != nil {
		pub.BodyRendered = ut.BodyRendered
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Markup != nil {
		pub.Markup = ut.Markup
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a comment. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type CommentAttributes struct {
	// The comment body
	Body *string `form:"body,omitempty" json:"body,omitempty" xml:"body,omitempty"`
	// The comment body rendered in HTML
	BodyRendered *string `form:"body.rendered,omitempty" json:"body.rendered,omitempty" xml:"body.rendered,omitempty"`
	// When the comment was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The comment markup associated with the body
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
	// When the comment was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
}

// commentCreatedBy user type.
type commentCreatedBy struct {
	Data  *identityRelationData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the commentCreatedBy type instance.
func (ut *commentCreatedBy) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CommentCreatedBy from commentCreatedBy
func (ut *commentCreatedBy) Publicize() *CommentCreatedBy {
	var pub CommentCreatedBy
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// CommentCreatedBy user type.
type CommentCreatedBy struct {
	Data  *IdentityRelationData `form:"data" json:"data" xml:"data"`
	Links *GenericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the CommentCreatedBy type instance.
func (ut *CommentCreatedBy) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// commentListMeta user type.
type commentListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the commentListMeta type instance.
func (ut *commentListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	return
}

// Publicize creates CommentListMeta from commentListMeta
func (ut *commentListMeta) Publicize() *CommentListMeta {
	var pub CommentListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// CommentListMeta user type.
type CommentListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// commentRelations user type.
type commentRelations struct {
	// DEPRECATED. This defines the creator of the comment.
	CreatedBy *commentCreatedBy `form:"created-by,omitempty" json:"created-by,omitempty" xml:"created-by,omitempty"`
	// This defines the creator of the comment
	Creator *relationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the owning resource of the comment
	Parent *relationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
}

// Validate validates the commentRelations type instance.
func (ut *commentRelations) Validate() (err error) {
	if ut.CreatedBy != nil {
		if err2 := ut.CreatedBy.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CommentRelations from commentRelations
func (ut *commentRelations) Publicize() *CommentRelations {
	var pub CommentRelations
	if ut.CreatedBy != nil {
		pub.CreatedBy = ut.CreatedBy.Publicize()
	}
	if ut.Creator != nil {
		pub.Creator = ut.Creator.Publicize()
	}
	if ut.Parent != nil {
		pub.Parent = ut.Parent.Publicize()
	}
	return &pub
}

// CommentRelations user type.
type CommentRelations struct {
	// DEPRECATED. This defines the creator of the comment.
	CreatedBy *CommentCreatedBy `form:"created-by,omitempty" json:"created-by,omitempty" xml:"created-by,omitempty"`
	// This defines the creator of the comment
	Creator *RelationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the owning resource of the comment
	Parent *RelationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
}

// Validate validates the CommentRelations type instance.
func (ut *CommentRelations) Validate() (err error) {
	if ut.CreatedBy != nil {
		if err2 := ut.CreatedBy.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// JSONAPI store for the data of a comment.  See also http://jsonapi.org/format/#document-resource-object
type createComment struct {
	Attributes *createCommentAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Type       *string                  `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the createComment type instance.
func (ut *createComment) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "comments") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"comments"}))
		}
	}
	return
}

// Publicize creates CreateComment from createComment
func (ut *createComment) Publicize() *CreateComment {
	var pub CreateComment
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a comment.  See also http://jsonapi.org/format/#document-resource-object
type CreateComment struct {
	Attributes *CreateCommentAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Type       string                   `form:"type" json:"type" xml:"type"`
}

// Validate validates the CreateComment type instance.
func (ut *CreateComment) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "comments") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"comments"}))
	}
	return
}

// JSONAPI store for all the "attributes" for creating a comment. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type createCommentAttributes struct {
	// The comment body
	Body *string `form:"body,omitempty" json:"body,omitempty" xml:"body,omitempty"`
	// The comment markup associated with the body
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
}

// Validate validates the createCommentAttributes type instance.
func (ut *createCommentAttributes) Validate() (err error) {
	if ut.Body == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "body"))
	}
	if ut.Body != nil {
		if utf8.RuneCountInString(*ut.Body) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.body`, *ut.Body, utf8.RuneCountInString(*ut.Body), 1, true))
		}
	}
	return
}

// Publicize creates CreateCommentAttributes from createCommentAttributes
func (ut *createCommentAttributes) Publicize() *CreateCommentAttributes {
	var pub CreateCommentAttributes
	if ut.Body != nil {
		pub.Body = *ut.Body
	}
	if ut.Markup != nil {
		pub.Markup = ut.Markup
	}
	return &pub
}

// JSONAPI store for all the "attributes" for creating a comment. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type CreateCommentAttributes struct {
	// The comment body
	Body string `form:"body" json:"body" xml:"body"`
	// The comment markup associated with the body
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
}

// Validate validates the CreateCommentAttributes type instance.
func (ut *CreateCommentAttributes) Validate() (err error) {
	if ut.Body == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "body"))
	}
	if utf8.RuneCountInString(ut.Body) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.body`, ut.Body, utf8.RuneCountInString(ut.Body), 1, true))
	}
	return
}

// createTrackerAlternatePayload user type.
type createTrackerAlternatePayload struct {
	// Type of the tracker
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// URL of the tracker
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
}

// Validate validates the createTrackerAlternatePayload type instance.
func (ut *createTrackerAlternatePayload) Validate() (err error) {
	if ut.URL == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "url"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Type != nil {
		if ok := goa.ValidatePattern(`^[\p{L}]+$`, *ut.Type); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.type`, *ut.Type, `^[\p{L}]+$`))
		}
	}
	if ut.Type != nil {
		if utf8.RuneCountInString(*ut.Type) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.type`, *ut.Type, utf8.RuneCountInString(*ut.Type), 1, true))
		}
	}
	if ut.URL != nil {
		if utf8.RuneCountInString(*ut.URL) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.url`, *ut.URL, utf8.RuneCountInString(*ut.URL), 1, true))
		}
	}
	return
}

// Publicize creates CreateTrackerAlternatePayload from createTrackerAlternatePayload
func (ut *createTrackerAlternatePayload) Publicize() *CreateTrackerAlternatePayload {
	var pub CreateTrackerAlternatePayload
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	if ut.URL != nil {
		pub.URL = *ut.URL
	}
	return &pub
}

// CreateTrackerAlternatePayload user type.
type CreateTrackerAlternatePayload struct {
	// Type of the tracker
	Type string `form:"type" json:"type" xml:"type"`
	// URL of the tracker
	URL string `form:"url" json:"url" xml:"url"`
}

// Validate validates the CreateTrackerAlternatePayload type instance.
func (ut *CreateTrackerAlternatePayload) Validate() (err error) {
	if ut.URL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "url"))
	}
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ok := goa.ValidatePattern(`^[\p{L}]+$`, ut.Type); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.type`, ut.Type, `^[\p{L}]+$`))
	}
	if utf8.RuneCountInString(ut.Type) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.type`, ut.Type, utf8.RuneCountInString(ut.Type), 1, true))
	}
	if utf8.RuneCountInString(ut.URL) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.url`, ut.URL, utf8.RuneCountInString(ut.URL), 1, true))
	}
	return
}

// createTrackerQueryAlternatePayload user type.
type createTrackerQueryAlternatePayload struct {
	// Search query
	Query         *string                    `form:"query,omitempty" json:"query,omitempty" xml:"query,omitempty"`
	Relationships *trackerQueryRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// Schedule for fetch and import
	Schedule *string `form:"schedule,omitempty" json:"schedule,omitempty" xml:"schedule,omitempty"`
	// Tracker ID
	TrackerID *string `form:"trackerID,omitempty" json:"trackerID,omitempty" xml:"trackerID,omitempty"`
}

// Validate validates the createTrackerQueryAlternatePayload type instance.
func (ut *createTrackerQueryAlternatePayload) Validate() (err error) {
	if ut.Query == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "query"))
	}
	if ut.Schedule == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "schedule"))
	}
	if ut.TrackerID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "trackerID"))
	}
	if ut.Query != nil {
		if utf8.RuneCountInString(*ut.Query) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.query`, *ut.Query, utf8.RuneCountInString(*ut.Query), 1, true))
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Schedule != nil {
		if ok := goa.ValidatePattern(`^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`, *ut.Schedule); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.schedule`, *ut.Schedule, `^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`))
		}
	}
	if ut.Schedule != nil {
		if utf8.RuneCountInString(*ut.Schedule) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.schedule`, *ut.Schedule, utf8.RuneCountInString(*ut.Schedule), 1, true))
		}
	}
	if ut.TrackerID != nil {
		if ok := goa.ValidatePattern(`^[\p{N}]+$`, *ut.TrackerID); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.trackerID`, *ut.TrackerID, `^[\p{N}]+$`))
		}
	}
	if ut.TrackerID != nil {
		if utf8.RuneCountInString(*ut.TrackerID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.trackerID`, *ut.TrackerID, utf8.RuneCountInString(*ut.TrackerID), 1, true))
		}
	}
	return
}

// Publicize creates CreateTrackerQueryAlternatePayload from createTrackerQueryAlternatePayload
func (ut *createTrackerQueryAlternatePayload) Publicize() *CreateTrackerQueryAlternatePayload {
	var pub CreateTrackerQueryAlternatePayload
	if ut.Query != nil {
		pub.Query = *ut.Query
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Schedule != nil {
		pub.Schedule = *ut.Schedule
	}
	if ut.TrackerID != nil {
		pub.TrackerID = *ut.TrackerID
	}
	return &pub
}

// CreateTrackerQueryAlternatePayload user type.
type CreateTrackerQueryAlternatePayload struct {
	// Search query
	Query         string                     `form:"query" json:"query" xml:"query"`
	Relationships *TrackerQueryRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// Schedule for fetch and import
	Schedule string `form:"schedule" json:"schedule" xml:"schedule"`
	// Tracker ID
	TrackerID string `form:"trackerID" json:"trackerID" xml:"trackerID"`
}

// Validate validates the CreateTrackerQueryAlternatePayload type instance.
func (ut *CreateTrackerQueryAlternatePayload) Validate() (err error) {
	if ut.Query == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "query"))
	}
	if ut.Schedule == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "schedule"))
	}
	if ut.TrackerID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "trackerID"))
	}
	if utf8.RuneCountInString(ut.Query) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.query`, ut.Query, utf8.RuneCountInString(ut.Query), 1, true))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ok := goa.ValidatePattern(`^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`, ut.Schedule); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.schedule`, ut.Schedule, `^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`))
	}
	if utf8.RuneCountInString(ut.Schedule) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.schedule`, ut.Schedule, utf8.RuneCountInString(ut.Schedule), 1, true))
	}
	if ok := goa.ValidatePattern(`^[\p{N}]+$`, ut.TrackerID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.trackerID`, ut.TrackerID, `^[\p{N}]+$`))
	}
	if utf8.RuneCountInString(ut.TrackerID) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.trackerID`, ut.TrackerID, utf8.RuneCountInString(ut.TrackerID), 1, true))
	}
	return
}

// createWorkItemLinkCategoryPayload user type.
type createWorkItemLinkCategoryPayload struct {
	Data *workItemLinkCategoryData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the createWorkItemLinkCategoryPayload type instance.
func (ut *createWorkItemLinkCategoryPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CreateWorkItemLinkCategoryPayload from createWorkItemLinkCategoryPayload
func (ut *createWorkItemLinkCategoryPayload) Publicize() *CreateWorkItemLinkCategoryPayload {
	var pub CreateWorkItemLinkCategoryPayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// CreateWorkItemLinkCategoryPayload user type.
type CreateWorkItemLinkCategoryPayload struct {
	Data *WorkItemLinkCategoryData `form:"data" json:"data" xml:"data"`
}

// Validate validates the CreateWorkItemLinkCategoryPayload type instance.
func (ut *CreateWorkItemLinkCategoryPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// createWorkItemLinkPayload user type.
type createWorkItemLinkPayload struct {
	Data *workItemLinkData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the createWorkItemLinkPayload type instance.
func (ut *createWorkItemLinkPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CreateWorkItemLinkPayload from createWorkItemLinkPayload
func (ut *createWorkItemLinkPayload) Publicize() *CreateWorkItemLinkPayload {
	var pub CreateWorkItemLinkPayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// CreateWorkItemLinkPayload user type.
type CreateWorkItemLinkPayload struct {
	Data *WorkItemLinkData `form:"data" json:"data" xml:"data"`
}

// Validate validates the CreateWorkItemLinkPayload type instance.
func (ut *CreateWorkItemLinkPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// createWorkItemLinkTypePayload user type.
type createWorkItemLinkTypePayload struct {
	Data *workItemLinkTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the createWorkItemLinkTypePayload type instance.
func (ut *createWorkItemLinkTypePayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates CreateWorkItemLinkTypePayload from createWorkItemLinkTypePayload
func (ut *createWorkItemLinkTypePayload) Publicize() *CreateWorkItemLinkTypePayload {
	var pub CreateWorkItemLinkTypePayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// CreateWorkItemLinkTypePayload user type.
type CreateWorkItemLinkTypePayload struct {
	Data *WorkItemLinkTypeData `form:"data" json:"data" xml:"data"`
}

// Validate validates the CreateWorkItemLinkTypePayload type instance.
func (ut *CreateWorkItemLinkTypePayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// createWorkItemPayload user type.
type createWorkItemPayload struct {
	// The field values, must conform to the type
	Fields map[string]interface{} `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
	// ID of the work item type of the newly created work item
	Type *uuid.UUID `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the createWorkItemPayload type instance.
func (ut *createWorkItemPayload) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "fields"))
	}
	if ut.Fields != nil {
		if len(ut.Fields) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.fields`, ut.Fields, len(ut.Fields), 1, true))
		}
	}
	return
}

// Publicize creates CreateWorkItemPayload from createWorkItemPayload
func (ut *createWorkItemPayload) Publicize() *CreateWorkItemPayload {
	var pub CreateWorkItemPayload
	if ut.Fields != nil {
		pub.Fields = ut.Fields
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// CreateWorkItemPayload user type.
type CreateWorkItemPayload struct {
	// The field values, must conform to the type
	Fields map[string]interface{} `form:"fields" json:"fields" xml:"fields"`
	// ID of the work item type of the newly created work item
	Type uuid.UUID `form:"type" json:"type" xml:"type"`
}

// Validate validates the CreateWorkItemPayload type instance.
func (ut *CreateWorkItemPayload) Validate() (err error) {

	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "fields"))
	}
	if len(ut.Fields) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.fields`, ut.Fields, len(ut.Fields), 1, true))
	}
	return
}

// genericData user type.
type genericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Publicize creates GenericData from genericData
func (ut *genericData) Publicize() *GenericData {
	var pub GenericData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// GenericData user type.
type GenericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// genericLinks user type.
type genericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinks from genericLinks
func (ut *genericLinks) Publicize() *GenericLinks {
	var pub GenericLinks
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinks user type.
type GenericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// genericLinksForSpace user type.
type genericLinksForSpace struct {
	// URL to the backlog work items
	Backlog *backlogGenericLink `form:"backlog,omitempty" json:"backlog,omitempty" xml:"backlog,omitempty"`
	// URL to the list of the space collaborators
	Collaborators *string `form:"collaborators,omitempty" json:"collaborators,omitempty" xml:"collaborators,omitempty"`
	// URL to the list of available filters
	Filters *string                `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
	// URL to list all WILTs for this space
	Workitemlinktypes *string `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// URL to the list all work item type groups
	Workitemtypegroups *string `form:"workitemtypegroups,omitempty" json:"workitemtypegroups,omitempty" xml:"workitemtypegroups,omitempty"`
	// URL to list all WITs for this space
	Workitemtypes *string `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// Validate validates the genericLinksForSpace type instance.
func (ut *genericLinksForSpace) Validate() (err error) {
	if ut.Backlog != nil {
		if err2 := ut.Backlog.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates GenericLinksForSpace from genericLinksForSpace
func (ut *genericLinksForSpace) Publicize() *GenericLinksForSpace {
	var pub GenericLinksForSpace
	if ut.Backlog != nil {
		pub.Backlog = ut.Backlog.Publicize()
	}
	if ut.Collaborators != nil {
		pub.Collaborators = ut.Collaborators
	}
	if ut.Filters != nil {
		pub.Filters = ut.Filters
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	if ut.Workitemlinktypes != nil {
		pub.Workitemlinktypes = ut.Workitemlinktypes
	}
	if ut.Workitemtypegroups != nil {
		pub.Workitemtypegroups = ut.Workitemtypegroups
	}
	if ut.Workitemtypes != nil {
		pub.Workitemtypes = ut.Workitemtypes
	}
	return &pub
}

// GenericLinksForSpace user type.
type GenericLinksForSpace struct {
	// URL to the backlog work items
	Backlog *BacklogGenericLink `form:"backlog,omitempty" json:"backlog,omitempty" xml:"backlog,omitempty"`
	// URL to the list of the space collaborators
	Collaborators *string `form:"collaborators,omitempty" json:"collaborators,omitempty" xml:"collaborators,omitempty"`
	// URL to the list of available filters
	Filters *string                `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
	// URL to list all WILTs for this space
	Workitemlinktypes *string `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// URL to the list all work item type groups
	Workitemtypegroups *string `form:"workitemtypegroups,omitempty" json:"workitemtypegroups,omitempty" xml:"workitemtypegroups,omitempty"`
	// URL to list all WITs for this space
	Workitemtypes *string `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// genericLinksForWorkItem user type.
type genericLinksForWorkItem struct {
	// URL to generate Che-editor's link based on values of codebase field
	EditCodebase *string                `form:"editCodebase,omitempty" json:"editCodebase,omitempty" xml:"editCodebase,omitempty"`
	Meta         map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related      *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self         *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinksForWorkItem from genericLinksForWorkItem
func (ut *genericLinksForWorkItem) Publicize() *GenericLinksForWorkItem {
	var pub GenericLinksForWorkItem
	if ut.EditCodebase != nil {
		pub.EditCodebase = ut.EditCodebase
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinksForWorkItem user type.
type GenericLinksForWorkItem struct {
	// URL to generate Che-editor's link based on values of codebase field
	EditCodebase *string                `form:"editCodebase,omitempty" json:"editCodebase,omitempty" xml:"editCodebase,omitempty"`
	Meta         map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related      *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self         *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// identityData user type.
type identityData struct {
	// Attributes of the user identity
	Attributes *identityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// unique id for the user identity
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the identityData type instance.
func (ut *identityData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// Publicize creates IdentityData from identityData
func (ut *identityData) Publicize() *IdentityData {
	var pub IdentityData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// IdentityData user type.
type IdentityData struct {
	// Attributes of the user identity
	Attributes *IdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// unique id for the user identity
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the IdentityData type instance.
func (ut *IdentityData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// identityDataAttributes user type.
type identityDataAttributes struct {
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates IdentityDataAttributes from identityDataAttributes
func (ut *identityDataAttributes) Publicize() *IdentityDataAttributes {
	var pub IdentityDataAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.ProviderType != nil {
		pub.ProviderType = ut.ProviderType
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// IdentityDataAttributes user type.
type IdentityDataAttributes struct {
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// identityRelationData user type.
type identityRelationData struct {
	// unique id for the user identity
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the identityRelationData type instance.
func (ut *identityRelationData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "identities") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"identities"}))
		}
	}
	return
}

// Publicize creates IdentityRelationData from identityRelationData
func (ut *identityRelationData) Publicize() *IdentityRelationData {
	var pub IdentityRelationData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// IdentityRelationData user type.
type IdentityRelationData struct {
	// unique id for the user identity
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the IdentityRelationData type instance.
func (ut *IdentityRelationData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if !(ut.Type == "identities") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"identities"}))
	}
	return
}

// JSONAPI store for the data of a iteration.  See also http://jsonapi.org/format/#document-resource-object
type iteration struct {
	Attributes *iterationAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of iteration
	ID            *uuid.UUID          `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks       `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *iterationRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string             `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the iteration type instance.
func (ut *iteration) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "iterations") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"iterations"}))
		}
	}
	return
}

// Publicize creates Iteration from iteration
func (ut *iteration) Publicize() *Iteration {
	var pub Iteration
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a iteration.  See also http://jsonapi.org/format/#document-resource-object
type Iteration struct {
	Attributes *IterationAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of iteration
	ID            *uuid.UUID          `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks       `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *IterationRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string              `form:"type" json:"type" xml:"type"`
}

// Validate validates the Iteration type instance.
func (ut *Iteration) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "iterations") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"iterations"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a iteration. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type iterationAttributes struct {
	// Active status of iteration calculated using user_active, startAt and endAt
	ActiveStatus *bool `form:"active_status,omitempty" json:"active_status,omitempty" xml:"active_status,omitempty"`
	// When the iteration was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description of the iteration
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// When the iteration ends
	EndAt *time.Time `form:"endAt,omitempty" json:"endAt,omitempty" xml:"endAt,omitempty"`
	// The iteration name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Path string separataed by / having UUIDs of all parent iterations
	ParentPath *string `form:"parent_path,omitempty" json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// Path string separataed by / having names of all parent iterations
	ResolvedParentPath *string `form:"resolved_parent_path,omitempty" json:"resolved_parent_path,omitempty" xml:"resolved_parent_path,omitempty"`
	// When the iteration starts
	StartAt *time.Time `form:"startAt,omitempty" json:"startAt,omitempty" xml:"startAt,omitempty"`
	// State of an iteration
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// When the iteration was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Active flag set by user
	UserActive *bool `form:"user_active,omitempty" json:"user_active,omitempty" xml:"user_active,omitempty"`
}

// Validate validates the iterationAttributes type instance.
func (ut *iterationAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	if ut.State != nil {
		if !(*ut.State == "new" || *ut.State == "start" || *ut.State == "close") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.state`, *ut.State, []interface{}{"new", "start", "close"}))
		}
	}
	return
}

// Publicize creates IterationAttributes from iterationAttributes
func (ut *iterationAttributes) Publicize() *IterationAttributes {
	var pub IterationAttributes
	if ut.ActiveStatus != nil {
		pub.ActiveStatus = ut.ActiveStatus
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.EndAt != nil {
		pub.EndAt = ut.EndAt
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.ParentPath != nil {
		pub.ParentPath = ut.ParentPath
	}
	if ut.ResolvedParentPath != nil {
		pub.ResolvedParentPath = ut.ResolvedParentPath
	}
	if ut.StartAt != nil {
		pub.StartAt = ut.StartAt
	}
	if ut.State != nil {
		pub.State = ut.State
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.UserActive != nil {
		pub.UserActive = ut.UserActive
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a iteration. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type IterationAttributes struct {
	// Active status of iteration calculated using user_active, startAt and endAt
	ActiveStatus *bool `form:"active_status,omitempty" json:"active_status,omitempty" xml:"active_status,omitempty"`
	// When the iteration was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description of the iteration
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// When the iteration ends
	EndAt *time.Time `form:"endAt,omitempty" json:"endAt,omitempty" xml:"endAt,omitempty"`
	// The iteration name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Path string separataed by / having UUIDs of all parent iterations
	ParentPath *string `form:"parent_path,omitempty" json:"parent_path,omitempty" xml:"parent_path,omitempty"`
	// Path string separataed by / having names of all parent iterations
	ResolvedParentPath *string `form:"resolved_parent_path,omitempty" json:"resolved_parent_path,omitempty" xml:"resolved_parent_path,omitempty"`
	// When the iteration starts
	StartAt *time.Time `form:"startAt,omitempty" json:"startAt,omitempty" xml:"startAt,omitempty"`
	// State of an iteration
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// When the iteration was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Active flag set by user
	UserActive *bool `form:"user_active,omitempty" json:"user_active,omitempty" xml:"user_active,omitempty"`
}

// Validate validates the IterationAttributes type instance.
func (ut *IterationAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	if ut.State != nil {
		if !(*ut.State == "new" || *ut.State == "start" || *ut.State == "close") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.state`, *ut.State, []interface{}{"new", "start", "close"}))
		}
	}
	return
}

// iterationRelations user type.
type iterationRelations struct {
	// This defines the parent iteration
	Parent *relationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the workitems associated with the iteration
	Workitems *relationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
}

// Publicize creates IterationRelations from iterationRelations
func (ut *iterationRelations) Publicize() *IterationRelations {
	var pub IterationRelations
	if ut.Parent != nil {
		pub.Parent = ut.Parent.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	if ut.Workitems != nil {
		pub.Workitems = ut.Workitems.Publicize()
	}
	return &pub
}

// IterationRelations user type.
type IterationRelations struct {
	// This defines the parent iteration
	Parent *RelationGeneric `form:"parent,omitempty" json:"parent,omitempty" xml:"parent,omitempty"`
	// This defines the owning space
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
	// This defines the workitems associated with the iteration
	Workitems *RelationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type jSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this fields value can be localized.
	Detail *string `form:"detail,omitempty" json:"detail,omitempty" xml:"detail,omitempty"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*jSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the jSONAPIError type instance.
func (ut *jSONAPIError) Validate() (err error) {
	if ut.Detail == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "detail"))
	}
	return
}

// Publicize creates JSONAPIError from jSONAPIError
func (ut *jSONAPIError) Publicize() *JSONAPIError {
	var pub JSONAPIError
	if ut.Code != nil {
		pub.Code = ut.Code
	}
	if ut.Detail != nil {
		pub.Detail = *ut.Detail
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = make(map[string]*JSONAPILink, len(ut.Links))
		for k2, v2 := range ut.Links {
			pubk2 := k2
			var pubv2 *JSONAPILink
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Links[pubk2] = pubv2
		}
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Source != nil {
		pub.Source = ut.Source
	}
	if ut.Status != nil {
		pub.Status = ut.Status
	}
	if ut.Title != nil {
		pub.Title = ut.Title
	}
	return &pub
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type JSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this fields value can be localized.
	Detail string `form:"detail" json:"detail" xml:"detail"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*JSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the JSONAPIError type instance.
func (ut *JSONAPIError) Validate() (err error) {
	if ut.Detail == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "detail"))
	}
	return
}

// See also http://jsonapi.org/format/#document-links.
type jSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates JSONAPILink from jSONAPILink
func (ut *jSONAPILink) Publicize() *JSONAPILink {
	var pub JSONAPILink
	if ut.Href != nil {
		pub.Href = ut.Href
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// See also http://jsonapi.org/format/#document-links.
type JSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// markupRenderingData user type.
type markupRenderingData struct {
	Attributes *markupRenderingDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// an ID to conform to the JSON-API spec, even though it is meaningless in the case of the rendering endpoint. Can be null
	ID   *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the markupRenderingData type instance.
func (ut *markupRenderingData) Validate() (err error) {
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "rendering") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"rendering"}))
		}
	}
	return
}

// Publicize creates MarkupRenderingData from markupRenderingData
func (ut *markupRenderingData) Publicize() *MarkupRenderingData {
	var pub MarkupRenderingData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// MarkupRenderingData user type.
type MarkupRenderingData struct {
	Attributes *MarkupRenderingDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// an ID to conform to the JSON-API spec, even though it is meaningless in the case of the rendering endpoint. Can be null
	ID   string `form:"id" json:"id" xml:"id"`
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the MarkupRenderingData type instance.
func (ut *MarkupRenderingData) Validate() (err error) {
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "rendering") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"rendering"}))
	}
	return
}

// markupRenderingDataAttributes user type.
type markupRenderingDataAttributes struct {
	// The rendered content
	RenderedContent *string `form:"renderedContent,omitempty" json:"renderedContent,omitempty" xml:"renderedContent,omitempty"`
}

// Validate validates the markupRenderingDataAttributes type instance.
func (ut *markupRenderingDataAttributes) Validate() (err error) {
	if ut.RenderedContent == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "renderedContent"))
	}
	return
}

// Publicize creates MarkupRenderingDataAttributes from markupRenderingDataAttributes
func (ut *markupRenderingDataAttributes) Publicize() *MarkupRenderingDataAttributes {
	var pub MarkupRenderingDataAttributes
	if ut.RenderedContent != nil {
		pub.RenderedContent = *ut.RenderedContent
	}
	return &pub
}

// MarkupRenderingDataAttributes user type.
type MarkupRenderingDataAttributes struct {
	// The rendered content
	RenderedContent string `form:"renderedContent" json:"renderedContent" xml:"renderedContent"`
}

// Validate validates the MarkupRenderingDataAttributes type instance.
func (ut *MarkupRenderingDataAttributes) Validate() (err error) {
	if ut.RenderedContent == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "renderedContent"))
	}
	return
}

// A MarkupRenderingPayload describes the values that a render request can hold.
type markupRenderingPayload struct {
	Data *markupRenderingPayloadData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the markupRenderingPayload type instance.
func (ut *markupRenderingPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates MarkupRenderingPayload from markupRenderingPayload
func (ut *markupRenderingPayload) Publicize() *MarkupRenderingPayload {
	var pub MarkupRenderingPayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// A MarkupRenderingPayload describes the values that a render request can hold.
type MarkupRenderingPayload struct {
	Data *MarkupRenderingPayloadData `form:"data" json:"data" xml:"data"`
}

// Validate validates the MarkupRenderingPayload type instance.
func (ut *MarkupRenderingPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// markupRenderingPayloadData user type.
type markupRenderingPayloadData struct {
	Attributes *markupRenderingPayloadDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Type       *string                               `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the markupRenderingPayloadData type instance.
func (ut *markupRenderingPayloadData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "rendering") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"rendering"}))
		}
	}
	return
}

// Publicize creates MarkupRenderingPayloadData from markupRenderingPayloadData
func (ut *markupRenderingPayloadData) Publicize() *MarkupRenderingPayloadData {
	var pub MarkupRenderingPayloadData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// MarkupRenderingPayloadData user type.
type MarkupRenderingPayloadData struct {
	Attributes *MarkupRenderingPayloadDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Type       string                                `form:"type" json:"type" xml:"type"`
}

// Validate validates the MarkupRenderingPayloadData type instance.
func (ut *MarkupRenderingPayloadData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "rendering") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"rendering"}))
	}
	return
}

// markupRenderingPayloadDataAttributes user type.
type markupRenderingPayloadDataAttributes struct {
	// The content to render
	Content *string `form:"content,omitempty" json:"content,omitempty" xml:"content,omitempty"`
	// The markup language associated with the content to render
	Markup *string `form:"markup,omitempty" json:"markup,omitempty" xml:"markup,omitempty"`
}

// Validate validates the markupRenderingPayloadDataAttributes type instance.
func (ut *markupRenderingPayloadDataAttributes) Validate() (err error) {
	if ut.Content == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "content"))
	}
	if ut.Markup == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "markup"))
	}
	return
}

// Publicize creates MarkupRenderingPayloadDataAttributes from markupRenderingPayloadDataAttributes
func (ut *markupRenderingPayloadDataAttributes) Publicize() *MarkupRenderingPayloadDataAttributes {
	var pub MarkupRenderingPayloadDataAttributes
	if ut.Content != nil {
		pub.Content = *ut.Content
	}
	if ut.Markup != nil {
		pub.Markup = *ut.Markup
	}
	return &pub
}

// MarkupRenderingPayloadDataAttributes user type.
type MarkupRenderingPayloadDataAttributes struct {
	// The content to render
	Content string `form:"content" json:"content" xml:"content"`
	// The markup language associated with the content to render
	Markup string `form:"markup" json:"markup" xml:"markup"`
}

// Validate validates the MarkupRenderingPayloadDataAttributes type instance.
func (ut *MarkupRenderingPayloadDataAttributes) Validate() (err error) {
	if ut.Content == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "content"))
	}
	if ut.Markup == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "markup"))
	}
	return
}

// JSONAPI store for all the "attributes" of a Tenant namespace. See also see http://jsonapi.org/format/#document-resource-object-attributes
type namespaceAttributes struct {
	// The cluster url
	ClusterURL *string `form:"cluster-url,omitempty" json:"cluster-url,omitempty" xml:"cluster-url,omitempty"`
	// When the tenant was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The namespace name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The namespaces state
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The tenant namespaces
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// When the tenant was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The namespaces version
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the namespaceAttributes type instance.
func (ut *namespaceAttributes) Validate() (err error) {
	if ut.Type != nil {
		if !(*ut.Type == "che" || *ut.Type == "jenkins" || *ut.Type == "stage" || *ut.Type == "test" || *ut.Type == "run") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"che", "jenkins", "stage", "test", "run"}))
		}
	}
	return
}

// Publicize creates NamespaceAttributes from namespaceAttributes
func (ut *namespaceAttributes) Publicize() *NamespaceAttributes {
	var pub NamespaceAttributes
	if ut.ClusterURL != nil {
		pub.ClusterURL = ut.ClusterURL
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.State != nil {
		pub.State = ut.State
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a Tenant namespace. See also see http://jsonapi.org/format/#document-resource-object-attributes
type NamespaceAttributes struct {
	// The cluster url
	ClusterURL *string `form:"cluster-url,omitempty" json:"cluster-url,omitempty" xml:"cluster-url,omitempty"`
	// When the tenant was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The namespace name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The namespaces state
	State *string `form:"state,omitempty" json:"state,omitempty" xml:"state,omitempty"`
	// The tenant namespaces
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// When the tenant was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The namespaces version
	Version *string `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the NamespaceAttributes type instance.
func (ut *NamespaceAttributes) Validate() (err error) {
	if ut.Type != nil {
		if !(*ut.Type == "che" || *ut.Type == "jenkins" || *ut.Type == "stage" || *ut.Type == "test" || *ut.Type == "run") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"che", "jenkins", "stage", "test", "run"}))
		}
	}
	return
}

// refreshToken user type.
type refreshToken struct {
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
}

// Publicize creates RefreshToken from refreshToken
func (ut *refreshToken) Publicize() *RefreshToken {
	var pub RefreshToken
	if ut.RefreshToken != nil {
		pub.RefreshToken = ut.RefreshToken
	}
	return &pub
}

// RefreshToken user type.
type RefreshToken struct {
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
}

// relationBaseType user type.
type relationBaseType struct {
	Data  *baseTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the relationBaseType type instance.
func (ut *relationBaseType) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationBaseType from relationBaseType
func (ut *relationBaseType) Publicize() *RelationBaseType {
	var pub RelationBaseType
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// RelationBaseType user type.
type RelationBaseType struct {
	Data  *BaseTypeData `form:"data" json:"data" xml:"data"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the RelationBaseType type instance.
func (ut *RelationBaseType) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationGeneric user type.
type relationGeneric struct {
	Data  *genericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGeneric from relationGeneric
func (ut *relationGeneric) Publicize() *RelationGeneric {
	var pub RelationGeneric
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGeneric user type.
type RelationGeneric struct {
	Data  *GenericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationGenericList user type.
type relationGenericList struct {
	Data  []*genericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGenericList from relationGenericList
func (ut *relationGenericList) Publicize() *RelationGenericList {
	var pub RelationGenericList
	if ut.Data != nil {
		pub.Data = make([]*GenericData, len(ut.Data))
		for i2, elem2 := range ut.Data {
			pub.Data[i2] = elem2.Publicize()
		}
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGenericList user type.
type RelationGenericList struct {
	Data  []*GenericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationSpaces user type.
type relationSpaces struct {
	Data  *relationSpacesData    `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the relationSpaces type instance.
func (ut *relationSpaces) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationSpaces from relationSpaces
func (ut *relationSpaces) Publicize() *RelationSpaces {
	var pub RelationSpaces
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationSpaces user type.
type RelationSpaces struct {
	Data  *RelationSpacesData    `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the RelationSpaces type instance.
func (ut *RelationSpaces) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationSpacesData user type.
type relationSpacesData struct {
	// UUID for the space
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationSpacesData type instance.
func (ut *relationSpacesData) Validate() (err error) {
	if ut.Type != nil {
		if !(*ut.Type == "spaces") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"spaces"}))
		}
	}
	return
}

// Publicize creates RelationSpacesData from relationSpacesData
func (ut *relationSpacesData) Publicize() *RelationSpacesData {
	var pub RelationSpacesData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// RelationSpacesData user type.
type RelationSpacesData struct {
	// UUID for the space
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the RelationSpacesData type instance.
func (ut *RelationSpacesData) Validate() (err error) {
	if ut.Type != nil {
		if !(*ut.Type == "spaces") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"spaces"}))
		}
	}
	return
}

// relationWorkItem user type.
type relationWorkItem struct {
	Data *relationWorkItemData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the relationWorkItem type instance.
func (ut *relationWorkItem) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationWorkItem from relationWorkItem
func (ut *relationWorkItem) Publicize() *RelationWorkItem {
	var pub RelationWorkItem
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// RelationWorkItem user type.
type RelationWorkItem struct {
	Data *RelationWorkItemData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the RelationWorkItem type instance.
func (ut *RelationWorkItem) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationWorkItemData user type.
type relationWorkItemData struct {
	// ID (UUID) of the work item
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationWorkItemData type instance.
func (ut *relationWorkItemData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitems") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitems"}))
		}
	}
	return
}

// Publicize creates RelationWorkItemData from relationWorkItemData
func (ut *relationWorkItemData) Publicize() *RelationWorkItemData {
	var pub RelationWorkItemData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// RelationWorkItemData user type.
type RelationWorkItemData struct {
	// ID (UUID) of the work item
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the RelationWorkItemData type instance.
func (ut *RelationWorkItemData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}

	if !(ut.Type == "workitems") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitems"}))
	}
	return
}

// relationWorkItemLinkCategory user type.
type relationWorkItemLinkCategory struct {
	Data  *relationWorkItemLinkCategoryData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks                     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the relationWorkItemLinkCategory type instance.
func (ut *relationWorkItemLinkCategory) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationWorkItemLinkCategory from relationWorkItemLinkCategory
func (ut *relationWorkItemLinkCategory) Publicize() *RelationWorkItemLinkCategory {
	var pub RelationWorkItemLinkCategory
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// RelationWorkItemLinkCategory user type.
type RelationWorkItemLinkCategory struct {
	Data  *RelationWorkItemLinkCategoryData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks                     `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the RelationWorkItemLinkCategory type instance.
func (ut *RelationWorkItemLinkCategory) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationWorkItemLinkCategoryData user type.
type relationWorkItemLinkCategoryData struct {
	// ID of work item link category
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related source
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationWorkItemLinkCategoryData type instance.
func (ut *relationWorkItemLinkCategoryData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemlinkcategories") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemlinkcategories"}))
		}
	}
	return
}

// Publicize creates RelationWorkItemLinkCategoryData from relationWorkItemLinkCategoryData
func (ut *relationWorkItemLinkCategoryData) Publicize() *RelationWorkItemLinkCategoryData {
	var pub RelationWorkItemLinkCategoryData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// RelationWorkItemLinkCategoryData user type.
type RelationWorkItemLinkCategoryData struct {
	// ID of work item link category
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type of the related source
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the RelationWorkItemLinkCategoryData type instance.
func (ut *RelationWorkItemLinkCategoryData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}

	if !(ut.Type == "workitemlinkcategories") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemlinkcategories"}))
	}
	return
}

// relationWorkItemLinkType user type.
type relationWorkItemLinkType struct {
	Data *relationWorkItemLinkTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the relationWorkItemLinkType type instance.
func (ut *relationWorkItemLinkType) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationWorkItemLinkType from relationWorkItemLinkType
func (ut *relationWorkItemLinkType) Publicize() *RelationWorkItemLinkType {
	var pub RelationWorkItemLinkType
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// RelationWorkItemLinkType user type.
type RelationWorkItemLinkType struct {
	Data *RelationWorkItemLinkTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the RelationWorkItemLinkType type instance.
func (ut *RelationWorkItemLinkType) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationWorkItemLinkTypeData user type.
type relationWorkItemLinkTypeData struct {
	// ID of work item link type
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related source
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationWorkItemLinkTypeData type instance.
func (ut *relationWorkItemLinkTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemlinktypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemlinktypes"}))
		}
	}
	return
}

// Publicize creates RelationWorkItemLinkTypeData from relationWorkItemLinkTypeData
func (ut *relationWorkItemLinkTypeData) Publicize() *RelationWorkItemLinkTypeData {
	var pub RelationWorkItemLinkTypeData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// RelationWorkItemLinkTypeData user type.
type RelationWorkItemLinkTypeData struct {
	// ID of work item link type
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type of the related source
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the RelationWorkItemLinkTypeData type instance.
func (ut *RelationWorkItemLinkTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}

	if !(ut.Type == "workitemlinktypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemlinktypes"}))
	}
	return
}

// relationWorkItemType user type.
type relationWorkItemType struct {
	Data  *relationWorkItemTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks             `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the relationWorkItemType type instance.
func (ut *relationWorkItemType) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationWorkItemType from relationWorkItemType
func (ut *relationWorkItemType) Publicize() *RelationWorkItemType {
	var pub RelationWorkItemType
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// RelationWorkItemType user type.
type RelationWorkItemType struct {
	Data  *RelationWorkItemTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks             `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the RelationWorkItemType type instance.
func (ut *RelationWorkItemType) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// relationWorkItemTypeData user type.
type relationWorkItemTypeData struct {
	// ID of a work item type
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the relationWorkItemTypeData type instance.
func (ut *relationWorkItemTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemtypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemtypes"}))
		}
	}
	return
}

// Publicize creates RelationWorkItemTypeData from relationWorkItemTypeData
func (ut *relationWorkItemTypeData) Publicize() *RelationWorkItemTypeData {
	var pub RelationWorkItemTypeData
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// RelationWorkItemTypeData user type.
type RelationWorkItemTypeData struct {
	// ID of a work item type
	ID uuid.UUID `form:"id" json:"id" xml:"id"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the RelationWorkItemTypeData type instance.
func (ut *RelationWorkItemTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}

	if !(ut.Type == "workitemtypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemtypes"}))
	}
	return
}

// space user type.
type space struct {
	Attributes *spaceAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the space
	ID            *uuid.UUID            `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinksForSpace `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *spaceRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type of the related resource
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the space type instance.
func (ut *space) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Links != nil {
		if err2 := ut.Links.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "spaces") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"spaces"}))
		}
	}
	return
}

// Publicize creates Space from space
func (ut *space) Publicize() *Space {
	var pub Space
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// Space user type.
type Space struct {
	Attributes *SpaceAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the space
	ID            *uuid.UUID            `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinksForSpace `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *SpaceRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// The type of the related resource
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the Space type instance.
func (ut *Space) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "spaces") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"spaces"}))
	}
	return
}

// spaceAttributes user type.
type spaceAttributes struct {
	// When the space was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description for the space
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Name for the space
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// When the space was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the spaceAttributes type instance.
func (ut *spaceAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// Publicize creates SpaceAttributes from spaceAttributes
func (ut *spaceAttributes) Publicize() *SpaceAttributes {
	var pub SpaceAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// SpaceAttributes user type.
type SpaceAttributes struct {
	// When the space was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description for the space
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Name for the space
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// When the space was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the SpaceAttributes type instance.
func (ut *SpaceAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// spaceListMeta user type.
type spaceListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the spaceListMeta type instance.
func (ut *spaceListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	return
}

// Publicize creates SpaceListMeta from spaceListMeta
func (ut *spaceListMeta) Publicize() *SpaceListMeta {
	var pub SpaceListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// SpaceListMeta user type.
type SpaceListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// spaceOwnedBy user type.
type spaceOwnedBy struct {
	Data  *identityRelationData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the spaceOwnedBy type instance.
func (ut *spaceOwnedBy) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates SpaceOwnedBy from spaceOwnedBy
func (ut *spaceOwnedBy) Publicize() *SpaceOwnedBy {
	var pub SpaceOwnedBy
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	return &pub
}

// SpaceOwnedBy user type.
type SpaceOwnedBy struct {
	Data  *IdentityRelationData `form:"data" json:"data" xml:"data"`
	Links *GenericLinks         `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
}

// Validate validates the SpaceOwnedBy type instance.
func (ut *SpaceOwnedBy) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// spaceRelationships user type.
type spaceRelationships struct {
	// Space can have one or many areas
	Areas *relationGeneric `form:"areas,omitempty" json:"areas,omitempty" xml:"areas,omitempty"`
	// Space can have one or many codebases
	Codebases *relationGeneric `form:"codebases,omitempty" json:"codebases,omitempty" xml:"codebases,omitempty"`
	// Space can have one or many collaborators
	Collaborators *relationGeneric `form:"collaborators,omitempty" json:"collaborators,omitempty" xml:"collaborators,omitempty"`
	// Space can have one or many iterations
	Iterations *relationGeneric `form:"iterations,omitempty" json:"iterations,omitempty" xml:"iterations,omitempty"`
	// The owner of the Space
	OwnedBy *spaceOwnedBy `form:"owned-by,omitempty" json:"owned-by,omitempty" xml:"owned-by,omitempty"`
	// Space can have one or many work item link types
	Workitemlinktypes *relationGeneric `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// Space can have one or many work items
	Workitems *relationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
	// Space can have one or many work item types
	Workitemtypes *relationGeneric `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// Validate validates the spaceRelationships type instance.
func (ut *spaceRelationships) Validate() (err error) {
	if ut.OwnedBy != nil {
		if err2 := ut.OwnedBy.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates SpaceRelationships from spaceRelationships
func (ut *spaceRelationships) Publicize() *SpaceRelationships {
	var pub SpaceRelationships
	if ut.Areas != nil {
		pub.Areas = ut.Areas.Publicize()
	}
	if ut.Codebases != nil {
		pub.Codebases = ut.Codebases.Publicize()
	}
	if ut.Collaborators != nil {
		pub.Collaborators = ut.Collaborators.Publicize()
	}
	if ut.Iterations != nil {
		pub.Iterations = ut.Iterations.Publicize()
	}
	if ut.OwnedBy != nil {
		pub.OwnedBy = ut.OwnedBy.Publicize()
	}
	if ut.Workitemlinktypes != nil {
		pub.Workitemlinktypes = ut.Workitemlinktypes.Publicize()
	}
	if ut.Workitems != nil {
		pub.Workitems = ut.Workitems.Publicize()
	}
	if ut.Workitemtypes != nil {
		pub.Workitemtypes = ut.Workitemtypes.Publicize()
	}
	return &pub
}

// SpaceRelationships user type.
type SpaceRelationships struct {
	// Space can have one or many areas
	Areas *RelationGeneric `form:"areas,omitempty" json:"areas,omitempty" xml:"areas,omitempty"`
	// Space can have one or many codebases
	Codebases *RelationGeneric `form:"codebases,omitempty" json:"codebases,omitempty" xml:"codebases,omitempty"`
	// Space can have one or many collaborators
	Collaborators *RelationGeneric `form:"collaborators,omitempty" json:"collaborators,omitempty" xml:"collaborators,omitempty"`
	// Space can have one or many iterations
	Iterations *RelationGeneric `form:"iterations,omitempty" json:"iterations,omitempty" xml:"iterations,omitempty"`
	// The owner of the Space
	OwnedBy *SpaceOwnedBy `form:"owned-by,omitempty" json:"owned-by,omitempty" xml:"owned-by,omitempty"`
	// Space can have one or many work item link types
	Workitemlinktypes *RelationGeneric `form:"workitemlinktypes,omitempty" json:"workitemlinktypes,omitempty" xml:"workitemlinktypes,omitempty"`
	// Space can have one or many work items
	Workitems *RelationGeneric `form:"workitems,omitempty" json:"workitems,omitempty" xml:"workitems,omitempty"`
	// Space can have one or many work item types
	Workitemtypes *RelationGeneric `form:"workitemtypes,omitempty" json:"workitemtypes,omitempty" xml:"workitemtypes,omitempty"`
}

// Validate validates the SpaceRelationships type instance.
func (ut *SpaceRelationships) Validate() (err error) {
	if ut.OwnedBy != nil {
		if err2 := ut.OwnedBy.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// tokenData user type.
type tokenData struct {
	// Access token
	AccessToken *string `form:"access_token,omitempty" json:"access_token,omitempty" xml:"access_token,omitempty"`
	// Access token expires in seconds
	ExpiresIn *interface{} `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// Token is not valid if issued before this date
	NotBeforePolicy *interface{} `form:"not-before-policy,omitempty" json:"not-before-policy,omitempty" xml:"not-before-policy,omitempty"`
	// Refresh token expires in seconds
	RefreshExpiresIn *interface{} `form:"refresh_expires_in,omitempty" json:"refresh_expires_in,omitempty" xml:"refresh_expires_in,omitempty"`
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// Token type
	TokenType *string `form:"token_type,omitempty" json:"token_type,omitempty" xml:"token_type,omitempty"`
}

// Validate validates the tokenData type instance.
func (ut *tokenData) Validate() (err error) {
	if ut.ExpiresIn == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "expires_in"))
	}
	if ut.RefreshExpiresIn == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "refresh_expires_in"))
	}
	if ut.NotBeforePolicy == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "not-before-policy"))
	}
	return
}

// Publicize creates TokenData from tokenData
func (ut *tokenData) Publicize() *TokenData {
	var pub TokenData
	if ut.AccessToken != nil {
		pub.AccessToken = ut.AccessToken
	}
	if ut.ExpiresIn != nil {
		pub.ExpiresIn = *ut.ExpiresIn
	}
	if ut.NotBeforePolicy != nil {
		pub.NotBeforePolicy = *ut.NotBeforePolicy
	}
	if ut.RefreshExpiresIn != nil {
		pub.RefreshExpiresIn = *ut.RefreshExpiresIn
	}
	if ut.RefreshToken != nil {
		pub.RefreshToken = ut.RefreshToken
	}
	if ut.TokenType != nil {
		pub.TokenType = ut.TokenType
	}
	return &pub
}

// TokenData user type.
type TokenData struct {
	// Access token
	AccessToken *string `form:"access_token,omitempty" json:"access_token,omitempty" xml:"access_token,omitempty"`
	// Access token expires in seconds
	ExpiresIn interface{} `form:"expires_in" json:"expires_in" xml:"expires_in"`
	// Token is not valid if issued before this date
	NotBeforePolicy interface{} `form:"not-before-policy" json:"not-before-policy" xml:"not-before-policy"`
	// Refresh token expires in seconds
	RefreshExpiresIn interface{} `form:"refresh_expires_in" json:"refresh_expires_in" xml:"refresh_expires_in"`
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// Token type
	TokenType *string `form:"token_type,omitempty" json:"token_type,omitempty" xml:"token_type,omitempty"`
}

// Validate validates the TokenData type instance.
func (ut *TokenData) Validate() (err error) {

	return
}

// trackerQueryRelationships user type.
type trackerQueryRelationships struct {
	// This defines the owning space of this work item type.
	Space *relationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the trackerQueryRelationships type instance.
func (ut *trackerQueryRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates TrackerQueryRelationships from trackerQueryRelationships
func (ut *trackerQueryRelationships) Publicize() *TrackerQueryRelationships {
	var pub TrackerQueryRelationships
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// TrackerQueryRelationships user type.
type TrackerQueryRelationships struct {
	// This defines the owning space of this work item type.
	Space *RelationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the TrackerQueryRelationships type instance.
func (ut *TrackerQueryRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// updateIdentityDataAttributes user type.
type updateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The users full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// Complete the registration to proceed. This can only be set to true
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates UpdateIdentityDataAttributes from updateIdentityDataAttributes
func (ut *updateIdentityDataAttributes) Publicize() *UpdateIdentityDataAttributes {
	var pub UpdateIdentityDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.Email != nil {
		pub.Email = ut.Email
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// UpdateIdentityDataAttributes user type.
type UpdateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The users full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// Complete the registration to proceed. This can only be set to true
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// updateTrackerAlternatePayload user type.
type updateTrackerAlternatePayload struct {
	// Type of the tracker
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// URL of the tracker
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
}

// Validate validates the updateTrackerAlternatePayload type instance.
func (ut *updateTrackerAlternatePayload) Validate() (err error) {
	if ut.URL == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "url"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Type != nil {
		if ok := goa.ValidatePattern(`^[\p{L}]+$`, *ut.Type); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.type`, *ut.Type, `^[\p{L}]+$`))
		}
	}
	if ut.Type != nil {
		if utf8.RuneCountInString(*ut.Type) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.type`, *ut.Type, utf8.RuneCountInString(*ut.Type), 1, true))
		}
	}
	if ut.URL != nil {
		if utf8.RuneCountInString(*ut.URL) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.url`, *ut.URL, utf8.RuneCountInString(*ut.URL), 1, true))
		}
	}
	return
}

// Publicize creates UpdateTrackerAlternatePayload from updateTrackerAlternatePayload
func (ut *updateTrackerAlternatePayload) Publicize() *UpdateTrackerAlternatePayload {
	var pub UpdateTrackerAlternatePayload
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	if ut.URL != nil {
		pub.URL = *ut.URL
	}
	return &pub
}

// UpdateTrackerAlternatePayload user type.
type UpdateTrackerAlternatePayload struct {
	// Type of the tracker
	Type string `form:"type" json:"type" xml:"type"`
	// URL of the tracker
	URL string `form:"url" json:"url" xml:"url"`
}

// Validate validates the UpdateTrackerAlternatePayload type instance.
func (ut *UpdateTrackerAlternatePayload) Validate() (err error) {
	if ut.URL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "url"))
	}
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ok := goa.ValidatePattern(`^[\p{L}]+$`, ut.Type); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.type`, ut.Type, `^[\p{L}]+$`))
	}
	if utf8.RuneCountInString(ut.Type) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.type`, ut.Type, utf8.RuneCountInString(ut.Type), 1, true))
	}
	if utf8.RuneCountInString(ut.URL) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.url`, ut.URL, utf8.RuneCountInString(ut.URL), 1, true))
	}
	return
}

// updateTrackerQueryAlternatePayload user type.
type updateTrackerQueryAlternatePayload struct {
	// Search query
	Query         *string                    `form:"query,omitempty" json:"query,omitempty" xml:"query,omitempty"`
	Relationships *trackerQueryRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// Schedule for fetch and import
	Schedule *string `form:"schedule,omitempty" json:"schedule,omitempty" xml:"schedule,omitempty"`
	// Tracker ID
	TrackerID *string `form:"trackerID,omitempty" json:"trackerID,omitempty" xml:"trackerID,omitempty"`
}

// Validate validates the updateTrackerQueryAlternatePayload type instance.
func (ut *updateTrackerQueryAlternatePayload) Validate() (err error) {
	if ut.Query == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "query"))
	}
	if ut.Schedule == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "schedule"))
	}
	if ut.TrackerID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "trackerID"))
	}
	if ut.Query != nil {
		if utf8.RuneCountInString(*ut.Query) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.query`, *ut.Query, utf8.RuneCountInString(*ut.Query), 1, true))
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Schedule != nil {
		if ok := goa.ValidatePattern(`^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`, *ut.Schedule); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.schedule`, *ut.Schedule, `^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`))
		}
	}
	if ut.Schedule != nil {
		if utf8.RuneCountInString(*ut.Schedule) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.schedule`, *ut.Schedule, utf8.RuneCountInString(*ut.Schedule), 1, true))
		}
	}
	if ut.TrackerID != nil {
		if ok := goa.ValidatePattern(`[\p{N}]+`, *ut.TrackerID); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.trackerID`, *ut.TrackerID, `[\p{N}]+`))
		}
	}
	if ut.TrackerID != nil {
		if utf8.RuneCountInString(*ut.TrackerID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.trackerID`, *ut.TrackerID, utf8.RuneCountInString(*ut.TrackerID), 1, true))
		}
	}
	return
}

// Publicize creates UpdateTrackerQueryAlternatePayload from updateTrackerQueryAlternatePayload
func (ut *updateTrackerQueryAlternatePayload) Publicize() *UpdateTrackerQueryAlternatePayload {
	var pub UpdateTrackerQueryAlternatePayload
	if ut.Query != nil {
		pub.Query = *ut.Query
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Schedule != nil {
		pub.Schedule = *ut.Schedule
	}
	if ut.TrackerID != nil {
		pub.TrackerID = *ut.TrackerID
	}
	return &pub
}

// UpdateTrackerQueryAlternatePayload user type.
type UpdateTrackerQueryAlternatePayload struct {
	// Search query
	Query         string                     `form:"query" json:"query" xml:"query"`
	Relationships *TrackerQueryRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// Schedule for fetch and import
	Schedule string `form:"schedule" json:"schedule" xml:"schedule"`
	// Tracker ID
	TrackerID string `form:"trackerID" json:"trackerID" xml:"trackerID"`
}

// Validate validates the UpdateTrackerQueryAlternatePayload type instance.
func (ut *UpdateTrackerQueryAlternatePayload) Validate() (err error) {
	if ut.Query == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "query"))
	}
	if ut.Schedule == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "schedule"))
	}
	if ut.TrackerID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "trackerID"))
	}
	if utf8.RuneCountInString(ut.Query) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.query`, ut.Query, utf8.RuneCountInString(ut.Query), 1, true))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ok := goa.ValidatePattern(`^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`, ut.Schedule); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.schedule`, ut.Schedule, `^[\d]+|[\d]+[\/][\d]+|\*|\-|\?\s{0,6}$`))
	}
	if utf8.RuneCountInString(ut.Schedule) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.schedule`, ut.Schedule, utf8.RuneCountInString(ut.Schedule), 1, true))
	}
	if ok := goa.ValidatePattern(`[\p{N}]+`, ut.TrackerID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.trackerID`, ut.TrackerID, `[\p{N}]+`))
	}
	if utf8.RuneCountInString(ut.TrackerID) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.trackerID`, ut.TrackerID, utf8.RuneCountInString(ut.TrackerID), 1, true))
	}
	return
}

// updateUserData user type.
type updateUserData struct {
	// Attributes of the user identity
	Attributes *updateIdentityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Links      *genericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the updateUserData type instance.
func (ut *updateUserData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// Publicize creates UpdateUserData from updateUserData
func (ut *updateUserData) Publicize() *UpdateUserData {
	var pub UpdateUserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UpdateUserData user type.
type UpdateUserData struct {
	// Attributes of the user identity
	Attributes *UpdateIdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Links      *GenericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UpdateUserData type instance.
func (ut *UpdateUserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// JSONAPI store for the data of a user identity ID. See also http://jsonapi.org/format/#document-resource-object
type updateUserID struct {
	// user identity ID
	ID   *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the updateUserID type instance.
func (ut *updateUserID) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "identities") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"identities"}))
		}
	}
	return
}

// Publicize creates UpdateUserID from updateUserID
func (ut *updateUserID) Publicize() *UpdateUserID {
	var pub UpdateUserID
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a user identity ID. See also http://jsonapi.org/format/#document-resource-object
type UpdateUserID struct {
	// user identity ID
	ID   string `form:"id" json:"id" xml:"id"`
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UpdateUserID type instance.
func (ut *UpdateUserID) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if !(ut.Type == "identities") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"identities"}))
	}
	return
}

// updateWorkItemLinkCategoryPayload user type.
type updateWorkItemLinkCategoryPayload struct {
	Data *workItemLinkCategoryData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the updateWorkItemLinkCategoryPayload type instance.
func (ut *updateWorkItemLinkCategoryPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates UpdateWorkItemLinkCategoryPayload from updateWorkItemLinkCategoryPayload
func (ut *updateWorkItemLinkCategoryPayload) Publicize() *UpdateWorkItemLinkCategoryPayload {
	var pub UpdateWorkItemLinkCategoryPayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// UpdateWorkItemLinkCategoryPayload user type.
type UpdateWorkItemLinkCategoryPayload struct {
	Data *WorkItemLinkCategoryData `form:"data" json:"data" xml:"data"`
}

// Validate validates the UpdateWorkItemLinkCategoryPayload type instance.
func (ut *UpdateWorkItemLinkCategoryPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// updateWorkItemLinkPayload user type.
type updateWorkItemLinkPayload struct {
	Data *workItemLinkData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the updateWorkItemLinkPayload type instance.
func (ut *updateWorkItemLinkPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates UpdateWorkItemLinkPayload from updateWorkItemLinkPayload
func (ut *updateWorkItemLinkPayload) Publicize() *UpdateWorkItemLinkPayload {
	var pub UpdateWorkItemLinkPayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// UpdateWorkItemLinkPayload user type.
type UpdateWorkItemLinkPayload struct {
	Data *WorkItemLinkData `form:"data" json:"data" xml:"data"`
}

// Validate validates the UpdateWorkItemLinkPayload type instance.
func (ut *UpdateWorkItemLinkPayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// updateWorkItemLinkTypePayload user type.
type updateWorkItemLinkTypePayload struct {
	Data *workItemLinkTypeData `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
}

// Validate validates the updateWorkItemLinkTypePayload type instance.
func (ut *updateWorkItemLinkTypePayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates UpdateWorkItemLinkTypePayload from updateWorkItemLinkTypePayload
func (ut *updateWorkItemLinkTypePayload) Publicize() *UpdateWorkItemLinkTypePayload {
	var pub UpdateWorkItemLinkTypePayload
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	return &pub
}

// UpdateWorkItemLinkTypePayload user type.
type UpdateWorkItemLinkTypePayload struct {
	Data *WorkItemLinkTypeData `form:"data" json:"data" xml:"data"`
}

// Validate validates the UpdateWorkItemLinkTypePayload type instance.
func (ut *UpdateWorkItemLinkTypePayload) Validate() (err error) {
	if ut.Data == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "data"))
	}
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// updateWorkItemPayload user type.
type updateWorkItemPayload struct {
	// The order of execution of workitem
	Executionorder *float64 `form:"executionorder,omitempty" json:"executionorder,omitempty" xml:"executionorder,omitempty"`
	// The field values, must conform to the type
	Fields        map[string]interface{} `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
	Relationships *workItemRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// ID of the work item type
	Type *uuid.UUID `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Version for optimistic concurrency control
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the updateWorkItemPayload type instance.
func (ut *updateWorkItemPayload) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "fields"))
	}
	if ut.Version == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "version"))
	}
	if ut.Executionorder == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "executionorder"))
	}
	if ut.Fields != nil {
		if len(ut.Fields) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.fields`, ut.Fields, len(ut.Fields), 1, true))
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates UpdateWorkItemPayload from updateWorkItemPayload
func (ut *updateWorkItemPayload) Publicize() *UpdateWorkItemPayload {
	var pub UpdateWorkItemPayload
	if ut.Executionorder != nil {
		pub.Executionorder = *ut.Executionorder
	}
	if ut.Fields != nil {
		pub.Fields = ut.Fields
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	if ut.Version != nil {
		pub.Version = *ut.Version
	}
	return &pub
}

// UpdateWorkItemPayload user type.
type UpdateWorkItemPayload struct {
	// The order of execution of workitem
	Executionorder float64 `form:"executionorder" json:"executionorder" xml:"executionorder"`
	// The field values, must conform to the type
	Fields        map[string]interface{} `form:"fields" json:"fields" xml:"fields"`
	Relationships *WorkItemRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	// ID of the work item type
	Type uuid.UUID `form:"type" json:"type" xml:"type"`
	// Version for optimistic concurrency control
	Version int `form:"version" json:"version" xml:"version"`
}

// Validate validates the UpdateWorkItemPayload type instance.
func (ut *UpdateWorkItemPayload) Validate() (err error) {

	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "fields"))
	}

	if len(ut.Fields) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.fields`, ut.Fields, len(ut.Fields), 1, true))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// userData user type.
type userData struct {
	// Attributes of the user
	Attributes *userDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// unique id for the user
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the userData type instance.
func (ut *userData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// Publicize creates UserData from userData
func (ut *userData) Publicize() *UserData {
	var pub UserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UserData user type.
type UserData struct {
	// Attributes of the user
	Attributes *UserDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// unique id for the user
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UserData type instance.
func (ut *UserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// userDataAttributes user type.
type userDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The id of the corresponding Identity
	IdentityID *string `form:"identityID,omitempty" json:"identityID,omitempty" xml:"identityID,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates UserDataAttributes from userDataAttributes
func (ut *userDataAttributes) Publicize() *UserDataAttributes {
	var pub UserDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Email != nil {
		pub.Email = ut.Email
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.IdentityID != nil {
		pub.IdentityID = ut.IdentityID
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.ProviderType != nil {
		pub.ProviderType = ut.ProviderType
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.UserID != nil {
		pub.UserID = ut.UserID
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// UserDataAttributes user type.
type UserDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The id of the corresponding Identity
	IdentityID *string `form:"identityID,omitempty" json:"identityID,omitempty" xml:"identityID,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// userListMeta user type.
type userListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the userListMeta type instance.
func (ut *userListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	return
}

// Publicize creates UserListMeta from userListMeta
func (ut *userListMeta) Publicize() *UserListMeta {
	var pub UserListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// UserListMeta user type.
type UserListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// JSONAPI for the teant object. See also http://jsonapi.org/format/#document-resource-object
type userService struct {
	Attributes *userServiceAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of tenant
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the userService type instance.
func (ut *userService) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "userservices") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"userservices"}))
		}
	}
	return
}

// Publicize creates UserService from userService
func (ut *userService) Publicize() *UserService {
	var pub UserService
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI for the teant object. See also http://jsonapi.org/format/#document-resource-object
type UserService struct {
	Attributes *UserServiceAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of tenant
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  string        `form:"type" json:"type" xml:"type"`
}

// Validate validates the UserService type instance.
func (ut *UserService) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "userservices") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"userservices"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a UserService. See also see http://jsonapi.org/format/#document-resource-object-attributes
type userServiceAttributes struct {
	// When the tenant was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The tenant namespaces
	Namespaces []*namespaceAttributes `form:"namespaces,omitempty" json:"namespaces,omitempty" xml:"namespaces,omitempty"`
}

// Validate validates the userServiceAttributes type instance.
func (ut *userServiceAttributes) Validate() (err error) {
	for _, e := range ut.Namespaces {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Publicize creates UserServiceAttributes from userServiceAttributes
func (ut *userServiceAttributes) Publicize() *UserServiceAttributes {
	var pub UserServiceAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Namespaces != nil {
		pub.Namespaces = make([]*NamespaceAttributes, len(ut.Namespaces))
		for i2, elem2 := range ut.Namespaces {
			pub.Namespaces[i2] = elem2.Publicize()
		}
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a UserService. See also see http://jsonapi.org/format/#document-resource-object-attributes
type UserServiceAttributes struct {
	// When the tenant was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The tenant namespaces
	Namespaces []*NamespaceAttributes `form:"namespaces,omitempty" json:"namespaces,omitempty" xml:"namespaces,omitempty"`
}

// Validate validates the UserServiceAttributes type instance.
func (ut *UserServiceAttributes) Validate() (err error) {
	for _, e := range ut.Namespaces {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// workItem user type.
type workItem struct {
	Attributes map[string]interface{} `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of the work item which is being updated
	ID            *uuid.UUID               `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinksForWorkItem `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                  `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItem type instance.
func (ut *workItem) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitems") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitems"}))
		}
	}
	return
}

// Publicize creates WorkItem from workItem
func (ut *workItem) Publicize() *WorkItem {
	var pub WorkItem
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// WorkItem user type.
type WorkItem struct {
	Attributes map[string]interface{} `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of the work item which is being updated
	ID            *uuid.UUID               `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinksForWorkItem `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemRelationships   `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string                   `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItem type instance.
func (ut *WorkItem) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitems") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitems"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a work item link.
// See also see http://jsonapi.org/format/#document-resource-object-attributes
type workItemLinkAttributes struct {
	// When the space was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// When the space was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Publicize creates WorkItemLinkAttributes from workItemLinkAttributes
func (ut *workItemLinkAttributes) Publicize() *WorkItemLinkAttributes {
	var pub WorkItemLinkAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a work item link.
// See also see http://jsonapi.org/format/#document-resource-object-attributes
type WorkItemLinkAttributes struct {
	// When the space was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// When the space was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// JSONAPI store for all the "attributes" of a work item link category.
// See also http://jsonapi.org/format/#document-resource-object-attributes
type workItemLinkCategoryAttributes struct {
	// Description of the work item link category (optional)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Name of the work item link category (required on creation, optional on update)
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the workItemLinkCategoryAttributes type instance.
func (ut *workItemLinkCategoryAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// Publicize creates WorkItemLinkCategoryAttributes from workItemLinkCategoryAttributes
func (ut *workItemLinkCategoryAttributes) Publicize() *WorkItemLinkCategoryAttributes {
	var pub WorkItemLinkCategoryAttributes
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a work item link category.
// See also http://jsonapi.org/format/#document-resource-object-attributes
type WorkItemLinkCategoryAttributes struct {
	// Description of the work item link category (optional)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Name of the work item link category (required on creation, optional on update)
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the WorkItemLinkCategoryAttributes type instance.
func (ut *WorkItemLinkCategoryAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// JSONAPI store the data of a work item link category.
// See also http://jsonapi.org/format/#document-resource-object
type workItemLinkCategoryData struct {
	Attributes *workItemLinkCategoryAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item link category (optional during creation)
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemLinkCategoryData type instance.
func (ut *workItemLinkCategoryData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemlinkcategories") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemlinkcategories"}))
		}
	}
	return
}

// Publicize creates WorkItemLinkCategoryData from workItemLinkCategoryData
func (ut *workItemLinkCategoryData) Publicize() *WorkItemLinkCategoryData {
	var pub WorkItemLinkCategoryData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store the data of a work item link category.
// See also http://jsonapi.org/format/#document-resource-object
type WorkItemLinkCategoryData struct {
	Attributes *WorkItemLinkCategoryAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of work item link category (optional during creation)
	ID    *uuid.UUID    `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  string        `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemLinkCategoryData type instance.
func (ut *WorkItemLinkCategoryData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemlinkcategories") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemlinkcategories"}))
	}
	return
}

// workItemLinkCategoryLinks user type.
type workItemLinkCategoryLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemLinkCategoryLinks type instance.
func (ut *workItemLinkCategoryLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// Publicize creates WorkItemLinkCategoryLinks from workItemLinkCategoryLinks
func (ut *workItemLinkCategoryLinks) Publicize() *WorkItemLinkCategoryLinks {
	var pub WorkItemLinkCategoryLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemLinkCategoryLinks user type.
type WorkItemLinkCategoryLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemLinkCategoryLinks type instance.
func (ut *WorkItemLinkCategoryLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// workItemLinkCategoryListMeta user type.
type workItemLinkCategoryListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemLinkCategoryListMeta type instance.
func (ut *workItemLinkCategoryListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	if ut.TotalCount != nil {
		if *ut.TotalCount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`response.totalCount`, *ut.TotalCount, 0, true))
		}
	}
	return
}

// Publicize creates WorkItemLinkCategoryListMeta from workItemLinkCategoryListMeta
func (ut *workItemLinkCategoryListMeta) Publicize() *WorkItemLinkCategoryListMeta {
	var pub WorkItemLinkCategoryListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemLinkCategoryListMeta user type.
type WorkItemLinkCategoryListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// Validate validates the WorkItemLinkCategoryListMeta type instance.
func (ut *WorkItemLinkCategoryListMeta) Validate() (err error) {
	if ut.TotalCount < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.totalCount`, ut.TotalCount, 0, true))
	}
	return
}

// JSONAPI store for the data of a work item.
// See also http://jsonapi.org/format/#document-resource-object
type workItemLinkData struct {
	Attributes *workItemLinkAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item link (optional during creation)
	ID            *uuid.UUID                 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemLinkRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemLinkData type instance.
func (ut *workItemLinkData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "relationships"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemlinks") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemlinks"}))
		}
	}
	return
}

// Publicize creates WorkItemLinkData from workItemLinkData
func (ut *workItemLinkData) Publicize() *WorkItemLinkData {
	var pub WorkItemLinkData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a work item.
// See also http://jsonapi.org/format/#document-resource-object
type WorkItemLinkData struct {
	Attributes *WorkItemLinkAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item link (optional during creation)
	ID            *uuid.UUID                 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemLinkRelationships `form:"relationships" json:"relationships" xml:"relationships"`
	Type          string                     `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemLinkData type instance.
func (ut *WorkItemLinkData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "relationships"))
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemlinks") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemlinks"}))
	}
	return
}

// workItemLinkLinks user type.
type workItemLinkLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemLinkLinks type instance.
func (ut *workItemLinkLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// Publicize creates WorkItemLinkLinks from workItemLinkLinks
func (ut *workItemLinkLinks) Publicize() *WorkItemLinkLinks {
	var pub WorkItemLinkLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemLinkLinks user type.
type WorkItemLinkLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemLinkLinks type instance.
func (ut *WorkItemLinkLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// workItemLinkListMeta user type.
type workItemLinkListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemLinkListMeta type instance.
func (ut *workItemLinkListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	if ut.TotalCount != nil {
		if *ut.TotalCount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`response.totalCount`, *ut.TotalCount, 0, true))
		}
	}
	return
}

// Publicize creates WorkItemLinkListMeta from workItemLinkListMeta
func (ut *workItemLinkListMeta) Publicize() *WorkItemLinkListMeta {
	var pub WorkItemLinkListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemLinkListMeta user type.
type WorkItemLinkListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// Validate validates the WorkItemLinkListMeta type instance.
func (ut *WorkItemLinkListMeta) Validate() (err error) {
	if ut.TotalCount < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.totalCount`, ut.TotalCount, 0, true))
	}
	return
}

// JSONAPI store for the data of a work item link.
// See also http://jsonapi.org/format/#document-resource-object-relationships
type workItemLinkRelationships struct {
	// The work item link type of this work item link.
	LinkType *relationWorkItemLinkType `form:"link_type,omitempty" json:"link_type,omitempty" xml:"link_type,omitempty"`
	// Work item where the connection starts.
	Source *relationWorkItem `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// Work item where the connection ends.
	Target *relationWorkItem `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
}

// Validate validates the workItemLinkRelationships type instance.
func (ut *workItemLinkRelationships) Validate() (err error) {
	if ut.LinkType != nil {
		if err2 := ut.LinkType.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Source != nil {
		if err2 := ut.Source.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Target != nil {
		if err2 := ut.Target.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates WorkItemLinkRelationships from workItemLinkRelationships
func (ut *workItemLinkRelationships) Publicize() *WorkItemLinkRelationships {
	var pub WorkItemLinkRelationships
	if ut.LinkType != nil {
		pub.LinkType = ut.LinkType.Publicize()
	}
	if ut.Source != nil {
		pub.Source = ut.Source.Publicize()
	}
	if ut.Target != nil {
		pub.Target = ut.Target.Publicize()
	}
	return &pub
}

// JSONAPI store for the data of a work item link.
// See also http://jsonapi.org/format/#document-resource-object-relationships
type WorkItemLinkRelationships struct {
	// The work item link type of this work item link.
	LinkType *RelationWorkItemLinkType `form:"link_type,omitempty" json:"link_type,omitempty" xml:"link_type,omitempty"`
	// Work item where the connection starts.
	Source *RelationWorkItem `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// Work item where the connection ends.
	Target *RelationWorkItem `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
}

// Validate validates the WorkItemLinkRelationships type instance.
func (ut *WorkItemLinkRelationships) Validate() (err error) {
	if ut.LinkType != nil {
		if err2 := ut.LinkType.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Source != nil {
		if err2 := ut.Source.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Target != nil {
		if err2 := ut.Target.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// JSONAPI store for all the "attributes" of a work item link type.
// See also see http://jsonapi.org/format/#document-resource-object-attributes
type workItemLinkTypeAttributes struct {
	// Time of creation of the given work item type
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description of the work item link type (optional)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The forward oriented path from source to target is described with the forward name.
	// For example, if a bug blocks a user story, the forward name is "blocks". See also reverse name.
	ForwardName *string `form:"forward_name,omitempty" json:"forward_name,omitempty" xml:"forward_name,omitempty"`
	// Name of the work item link type (required on creation, optional on update)
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The backwards oriented path from target to source is described with the reverse name.
	// For example, if a bug blocks a user story, the reverse name name is "blocked by" as in: a user story is blocked by a bug. See also forward name.
	ReverseName *string `form:"reverse_name,omitempty" json:"reverse_name,omitempty" xml:"reverse_name,omitempty"`
	// The topology determines the restrictions placed on the usage of each work item link type.
	Topology *string `form:"topology,omitempty" json:"topology,omitempty" xml:"topology,omitempty"`
	// Time of last update of the given work item type
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the workItemLinkTypeAttributes type instance.
func (ut *workItemLinkTypeAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	if ut.Topology != nil {
		if !(*ut.Topology == "network" || *ut.Topology == "tree") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.topology`, *ut.Topology, []interface{}{"network", "tree"}))
		}
	}
	return
}

// Publicize creates WorkItemLinkTypeAttributes from workItemLinkTypeAttributes
func (ut *workItemLinkTypeAttributes) Publicize() *WorkItemLinkTypeAttributes {
	var pub WorkItemLinkTypeAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.ForwardName != nil {
		pub.ForwardName = ut.ForwardName
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.ReverseName != nil {
		pub.ReverseName = ut.ReverseName
	}
	if ut.Topology != nil {
		pub.Topology = ut.Topology
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a work item link type.
// See also see http://jsonapi.org/format/#document-resource-object-attributes
type WorkItemLinkTypeAttributes struct {
	// Time of creation of the given work item type
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// Description of the work item link type (optional)
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The forward oriented path from source to target is described with the forward name.
	// For example, if a bug blocks a user story, the forward name is "blocks". See also reverse name.
	ForwardName *string `form:"forward_name,omitempty" json:"forward_name,omitempty" xml:"forward_name,omitempty"`
	// Name of the work item link type (required on creation, optional on update)
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// The backwards oriented path from target to source is described with the reverse name.
	// For example, if a bug blocks a user story, the reverse name name is "blocked by" as in: a user story is blocked by a bug. See also forward name.
	ReverseName *string `form:"reverse_name,omitempty" json:"reverse_name,omitempty" xml:"reverse_name,omitempty"`
	// The topology determines the restrictions placed on the usage of each work item link type.
	Topology *string `form:"topology,omitempty" json:"topology,omitempty" xml:"topology,omitempty"`
	// Time of last update of the given work item type
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the WorkItemLinkTypeAttributes type instance.
func (ut *WorkItemLinkTypeAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	if ut.Topology != nil {
		if !(*ut.Topology == "network" || *ut.Topology == "tree") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.topology`, *ut.Topology, []interface{}{"network", "tree"}))
		}
	}
	return
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object
type workItemLinkTypeData struct {
	Attributes *workItemLinkTypeAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item link type (optional during creation)
	ID            *uuid.UUID                     `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks                  `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemLinkTypeRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                        `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemLinkTypeData type instance.
func (ut *workItemLinkTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemlinktypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemlinktypes"}))
		}
	}
	return
}

// Publicize creates WorkItemLinkTypeData from workItemLinkTypeData
func (ut *workItemLinkTypeData) Publicize() *WorkItemLinkTypeData {
	var pub WorkItemLinkTypeData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object
type WorkItemLinkTypeData struct {
	Attributes *WorkItemLinkTypeAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of work item link type (optional during creation)
	ID            *uuid.UUID                     `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks                  `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemLinkTypeRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string                         `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemLinkTypeData type instance.
func (ut *WorkItemLinkTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemlinktypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemlinktypes"}))
	}
	return
}

// workItemLinkTypeLinks user type.
type workItemLinkTypeLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemLinkTypeLinks type instance.
func (ut *workItemLinkTypeLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// Publicize creates WorkItemLinkTypeLinks from workItemLinkTypeLinks
func (ut *workItemLinkTypeLinks) Publicize() *WorkItemLinkTypeLinks {
	var pub WorkItemLinkTypeLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemLinkTypeLinks user type.
type WorkItemLinkTypeLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemLinkTypeLinks type instance.
func (ut *WorkItemLinkTypeLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// workItemLinkTypeListMeta user type.
type workItemLinkTypeListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemLinkTypeListMeta type instance.
func (ut *workItemLinkTypeListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	if ut.TotalCount != nil {
		if *ut.TotalCount < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`response.totalCount`, *ut.TotalCount, 0, true))
		}
	}
	return
}

// Publicize creates WorkItemLinkTypeListMeta from workItemLinkTypeListMeta
func (ut *workItemLinkTypeListMeta) Publicize() *WorkItemLinkTypeListMeta {
	var pub WorkItemLinkTypeListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemLinkTypeListMeta user type.
type WorkItemLinkTypeListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// Validate validates the WorkItemLinkTypeListMeta type instance.
func (ut *WorkItemLinkTypeListMeta) Validate() (err error) {
	if ut.TotalCount < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.totalCount`, ut.TotalCount, 0, true))
	}
	return
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object-relationships
type workItemLinkTypeRelationships struct {
	// The work item link category of this work item link type.
	LinkCategory *relationWorkItemLinkCategory `form:"link_category,omitempty" json:"link_category,omitempty" xml:"link_category,omitempty"`
	// This defines the owning space of this work item link type.
	Space *relationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the workItemLinkTypeRelationships type instance.
func (ut *workItemLinkTypeRelationships) Validate() (err error) {
	if ut.LinkCategory != nil {
		if err2 := ut.LinkCategory.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates WorkItemLinkTypeRelationships from workItemLinkTypeRelationships
func (ut *workItemLinkTypeRelationships) Publicize() *WorkItemLinkTypeRelationships {
	var pub WorkItemLinkTypeRelationships
	if ut.LinkCategory != nil {
		pub.LinkCategory = ut.LinkCategory.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object-relationships
type WorkItemLinkTypeRelationships struct {
	// The work item link category of this work item link type.
	LinkCategory *RelationWorkItemLinkCategory `form:"link_category,omitempty" json:"link_category,omitempty" xml:"link_category,omitempty"`
	// This defines the owning space of this work item link type.
	Space *RelationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the WorkItemLinkTypeRelationships type instance.
func (ut *WorkItemLinkTypeRelationships) Validate() (err error) {
	if ut.LinkCategory != nil {
		if err2 := ut.LinkCategory.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// workItemLinks user type.
type workItemLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemLinks type instance.
func (ut *workItemLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// Publicize creates WorkItemLinks from workItemLinks
func (ut *workItemLinks) Publicize() *WorkItemLinks {
	var pub WorkItemLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemLinks user type.
type WorkItemLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemLinks type instance.
func (ut *WorkItemLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// workItemRelationships user type.
type workItemRelationships struct {
	// This defines the area this work item belongs to
	Area *relationGeneric `form:"area,omitempty" json:"area,omitempty" xml:"area,omitempty"`
	// This defines assignees of the Work Item
	Assignees *relationGenericList `form:"assignees,omitempty" json:"assignees,omitempty" xml:"assignees,omitempty"`
	// This defines type of Work Item
	BaseType *relationBaseType `form:"baseType,omitempty" json:"baseType,omitempty" xml:"baseType,omitempty"`
	// This defines the children of this work item
	Children *relationGeneric `form:"children,omitempty" json:"children,omitempty" xml:"children,omitempty"`
	// This defines comments on the Work Item
	Comments *relationGeneric `form:"comments,omitempty" json:"comments,omitempty" xml:"comments,omitempty"`
	// This defines creator of the Work Item
	Creator *relationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the iteration this work item belong to
	Iteration *relationGeneric `form:"iteration,omitempty" json:"iteration,omitempty" xml:"iteration,omitempty"`
	// This defines the owning space of this work item.
	Space *relationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the workItemRelationships type instance.
func (ut *workItemRelationships) Validate() (err error) {
	if ut.BaseType != nil {
		if err2 := ut.BaseType.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates WorkItemRelationships from workItemRelationships
func (ut *workItemRelationships) Publicize() *WorkItemRelationships {
	var pub WorkItemRelationships
	if ut.Area != nil {
		pub.Area = ut.Area.Publicize()
	}
	if ut.Assignees != nil {
		pub.Assignees = ut.Assignees.Publicize()
	}
	if ut.BaseType != nil {
		pub.BaseType = ut.BaseType.Publicize()
	}
	if ut.Children != nil {
		pub.Children = ut.Children.Publicize()
	}
	if ut.Comments != nil {
		pub.Comments = ut.Comments.Publicize()
	}
	if ut.Creator != nil {
		pub.Creator = ut.Creator.Publicize()
	}
	if ut.Iteration != nil {
		pub.Iteration = ut.Iteration.Publicize()
	}
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// WorkItemRelationships user type.
type WorkItemRelationships struct {
	// This defines the area this work item belongs to
	Area *RelationGeneric `form:"area,omitempty" json:"area,omitempty" xml:"area,omitempty"`
	// This defines assignees of the Work Item
	Assignees *RelationGenericList `form:"assignees,omitempty" json:"assignees,omitempty" xml:"assignees,omitempty"`
	// This defines type of Work Item
	BaseType *RelationBaseType `form:"baseType,omitempty" json:"baseType,omitempty" xml:"baseType,omitempty"`
	// This defines the children of this work item
	Children *RelationGeneric `form:"children,omitempty" json:"children,omitempty" xml:"children,omitempty"`
	// This defines comments on the Work Item
	Comments *RelationGeneric `form:"comments,omitempty" json:"comments,omitempty" xml:"comments,omitempty"`
	// This defines creator of the Work Item
	Creator *RelationGeneric `form:"creator,omitempty" json:"creator,omitempty" xml:"creator,omitempty"`
	// This defines the iteration this work item belong to
	Iteration *RelationGeneric `form:"iteration,omitempty" json:"iteration,omitempty" xml:"iteration,omitempty"`
	// This defines the owning space of this work item.
	Space *RelationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the WorkItemRelationships type instance.
func (ut *WorkItemRelationships) Validate() (err error) {
	if ut.BaseType != nil {
		if err2 := ut.BaseType.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// A work item type describes the values a work item type instance can hold.
type workItemTypeAttributes struct {
	// timestamp of entity creation
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// A human readable description for the work item type
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If newly created type extends any existing type (This is never present in any response and is only optional when creating.)
	ExtendedTypeName *uuid.UUID `form:"extendedTypeName,omitempty" json:"extendedTypeName,omitempty" xml:"extendedTypeName,omitempty"`
	// Definitions of fields in this work item type
	Fields map[string]*fieldDefinition `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
	// CSS class string for an icon to use. See http://fontawesome.io/icons/ or http://www.patternfly.org/styles/icons/#_ for examples.
	Icon *string `form:"icon,omitempty" json:"icon,omitempty" xml:"icon,omitempty"`
	// The human readable name of the work item type
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// timestamp of last entity update
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the workItemTypeAttributes type instance.
func (ut *workItemTypeAttributes) Validate() (err error) {
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "fields"))
	}
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}
	if ut.Icon == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "icon"))
	}
	if ut.Fields != nil {
		if len(ut.Fields) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.fields`, ut.Fields, len(ut.Fields), 1, true))
		}
	}
	if ut.Icon != nil {
		if utf8.RuneCountInString(*ut.Icon) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.icon`, *ut.Icon, utf8.RuneCountInString(*ut.Icon), 1, true))
		}
	}
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 62 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 62, false))
		}
	}
	return
}

// Publicize creates WorkItemTypeAttributes from workItemTypeAttributes
func (ut *workItemTypeAttributes) Publicize() *WorkItemTypeAttributes {
	var pub WorkItemTypeAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.ExtendedTypeName != nil {
		pub.ExtendedTypeName = ut.ExtendedTypeName
	}
	if ut.Fields != nil {
		pub.Fields = make(map[string]*FieldDefinition, len(ut.Fields))
		for k2, v2 := range ut.Fields {
			pubk2 := k2
			var pubv2 *FieldDefinition
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Fields[pubk2] = pubv2
		}
	}
	if ut.Icon != nil {
		pub.Icon = *ut.Icon
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// A work item type describes the values a work item type instance can hold.
type WorkItemTypeAttributes struct {
	// timestamp of entity creation
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// A human readable description for the work item type
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// If newly created type extends any existing type (This is never present in any response and is only optional when creating.)
	ExtendedTypeName *uuid.UUID `form:"extendedTypeName,omitempty" json:"extendedTypeName,omitempty" xml:"extendedTypeName,omitempty"`
	// Definitions of fields in this work item type
	Fields map[string]*FieldDefinition `form:"fields" json:"fields" xml:"fields"`
	// CSS class string for an icon to use. See http://fontawesome.io/icons/ or http://www.patternfly.org/styles/icons/#_ for examples.
	Icon string `form:"icon" json:"icon" xml:"icon"`
	// The human readable name of the work item type
	Name string `form:"name" json:"name" xml:"name"`
	// timestamp of last entity update
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the WorkItemTypeAttributes type instance.
func (ut *WorkItemTypeAttributes) Validate() (err error) {
	if ut.Fields == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "fields"))
	}
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}
	if ut.Icon == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "icon"))
	}
	if len(ut.Fields) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.fields`, ut.Fields, len(ut.Fields), 1, true))
	}
	if utf8.RuneCountInString(ut.Icon) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.icon`, ut.Icon, utf8.RuneCountInString(ut.Icon), 1, true))
	}
	if ok := goa.ValidatePattern(`^[^_|-].*`, ut.Name); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.name`, ut.Name, `^[^_|-].*`))
	}
	if utf8.RuneCountInString(ut.Name) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, ut.Name, utf8.RuneCountInString(ut.Name), 1, true))
	}
	if utf8.RuneCountInString(ut.Name) > 62 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.name`, ut.Name, utf8.RuneCountInString(ut.Name), 62, false))
	}
	return
}

// workItemTypeData user type.
type workItemTypeData struct {
	Attributes *workItemTypeAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of work item type (optional during creation)
	ID            *uuid.UUID                 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *workItemTypeRelationships `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string                    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemTypeData type instance.
func (ut *workItemTypeData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "relationships"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemtypes") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemtypes"}))
		}
	}
	return
}

// Publicize creates WorkItemTypeData from workItemTypeData
func (ut *workItemTypeData) Publicize() *WorkItemTypeData {
	var pub WorkItemTypeData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// WorkItemTypeData user type.
type WorkItemTypeData struct {
	Attributes *WorkItemTypeAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of work item type (optional during creation)
	ID            *uuid.UUID                 `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks              `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *WorkItemTypeRelationships `form:"relationships" json:"relationships" xml:"relationships"`
	Type          string                     `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemTypeData type instance.
func (ut *WorkItemTypeData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Relationships == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "relationships"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Relationships != nil {
		if err2 := ut.Relationships.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemtypes") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemtypes"}))
	}
	return
}

// workItemTypeGroup user type.
type workItemTypeGroup struct {
	// Name of the group this node belongs to
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
	// Hierarchical position within the group
	Level []int   `form:"level,omitempty" json:"level,omitempty" xml:"level,omitempty"`
	Name  *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Slice of UUIDs of work item type
	WitCollection []uuid.UUID `form:"wit_collection,omitempty" json:"wit_collection,omitempty" xml:"wit_collection,omitempty"`
}

// Validate validates the workItemTypeGroup type instance.
func (ut *workItemTypeGroup) Validate() (err error) {
	if ut.Level == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "level"))
	}
	if ut.Group == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "group"))
	}
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}
	if ut.WitCollection == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "wit_collection"))
	}
	return
}

// Publicize creates WorkItemTypeGroup from workItemTypeGroup
func (ut *workItemTypeGroup) Publicize() *WorkItemTypeGroup {
	var pub WorkItemTypeGroup
	if ut.Group != nil {
		pub.Group = *ut.Group
	}
	if ut.Level != nil {
		pub.Level = ut.Level
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.WitCollection != nil {
		pub.WitCollection = ut.WitCollection
	}
	return &pub
}

// WorkItemTypeGroup user type.
type WorkItemTypeGroup struct {
	// Name of the group this node belongs to
	Group string `form:"group" json:"group" xml:"group"`
	// Hierarchical position within the group
	Level []int  `form:"level" json:"level" xml:"level"`
	Name  string `form:"name" json:"name" xml:"name"`
	// Slice of UUIDs of work item type
	WitCollection []uuid.UUID `form:"wit_collection" json:"wit_collection" xml:"wit_collection"`
}

// Validate validates the WorkItemTypeGroup type instance.
func (ut *WorkItemTypeGroup) Validate() (err error) {
	if ut.Level == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "level"))
	}
	if ut.Group == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "group"))
	}
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}
	if ut.WitCollection == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "wit_collection"))
	}
	return
}

// workItemTypeGroupAttributes user type.
type workItemTypeGroupAttributes struct {
	Hierarchy []*workItemTypeGroup `form:"hierarchy,omitempty" json:"hierarchy,omitempty" xml:"hierarchy,omitempty"`
}

// Validate validates the workItemTypeGroupAttributes type instance.
func (ut *workItemTypeGroupAttributes) Validate() (err error) {
	if ut.Hierarchy == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "hierarchy"))
	}
	for _, e := range ut.Hierarchy {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Publicize creates WorkItemTypeGroupAttributes from workItemTypeGroupAttributes
func (ut *workItemTypeGroupAttributes) Publicize() *WorkItemTypeGroupAttributes {
	var pub WorkItemTypeGroupAttributes
	if ut.Hierarchy != nil {
		pub.Hierarchy = make([]*WorkItemTypeGroup, len(ut.Hierarchy))
		for i2, elem2 := range ut.Hierarchy {
			pub.Hierarchy[i2] = elem2.Publicize()
		}
	}
	return &pub
}

// WorkItemTypeGroupAttributes user type.
type WorkItemTypeGroupAttributes struct {
	Hierarchy []*WorkItemTypeGroup `form:"hierarchy" json:"hierarchy" xml:"hierarchy"`
}

// Validate validates the WorkItemTypeGroupAttributes type instance.
func (ut *WorkItemTypeGroupAttributes) Validate() (err error) {
	if ut.Hierarchy == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "hierarchy"))
	}
	for _, e := range ut.Hierarchy {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object
type workItemTypeGroupData struct {
	Attributes *workItemTypeGroupAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// The type string of the work item type group
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workItemTypeGroupData type instance.
func (ut *workItemTypeGroupData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "workitemtypegroups") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workitemtypegroups"}))
		}
	}
	return
}

// Publicize creates WorkItemTypeGroupData from workItemTypeGroupData
func (ut *workItemTypeGroupData) Publicize() *WorkItemTypeGroupData {
	var pub WorkItemTypeGroupData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a work item link type.
// See also http://jsonapi.org/format/#document-resource-object
type WorkItemTypeGroupData struct {
	Attributes *WorkItemTypeGroupAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// The type string of the work item type group
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the WorkItemTypeGroupData type instance.
func (ut *WorkItemTypeGroupData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "workitemtypegroups") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workitemtypegroups"}))
	}
	return
}

// workItemTypeLinks user type.
type workItemTypeLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemTypeLinks type instance.
func (ut *workItemTypeLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// Publicize creates WorkItemTypeLinks from workItemTypeLinks
func (ut *workItemTypeLinks) Publicize() *WorkItemTypeLinks {
	var pub WorkItemTypeLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemTypeLinks user type.
type WorkItemTypeLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemTypeLinks type instance.
func (ut *WorkItemTypeLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// workItemTypeListMeta user type.
type workItemTypeListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemTypeListMeta type instance.
func (ut *workItemTypeListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	return
}

// Publicize creates WorkItemTypeListMeta from workItemTypeListMeta
func (ut *workItemTypeListMeta) Publicize() *WorkItemTypeListMeta {
	var pub WorkItemTypeListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemTypeListMeta user type.
type WorkItemTypeListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// workItemTypeRelationships user type.
type workItemTypeRelationships struct {
	// This defines the owning space of this work item type.
	Space *relationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the workItemTypeRelationships type instance.
func (ut *workItemTypeRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates WorkItemTypeRelationships from workItemTypeRelationships
func (ut *workItemTypeRelationships) Publicize() *WorkItemTypeRelationships {
	var pub WorkItemTypeRelationships
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// WorkItemTypeRelationships user type.
type WorkItemTypeRelationships struct {
	// This defines the owning space of this work item type.
	Space *RelationSpaces `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Validate validates the WorkItemTypeRelationships type instance.
func (ut *WorkItemTypeRelationships) Validate() (err error) {
	if ut.Space != nil {
		if err2 := ut.Space.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// JSONAPI store for the data of a workspace.  See also http://jsonapi.org/format/#document-resource-object
type workspace struct {
	Attributes *workspaceAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Links      *workspaceLinks      `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type       *string              `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the workspace type instance.
func (ut *workspace) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "workspaces") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"workspaces"}))
		}
	}
	return
}

// Publicize creates Workspace from workspace
func (ut *workspace) Publicize() *Workspace {
	var pub Workspace
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a workspace.  See also http://jsonapi.org/format/#document-resource-object
type Workspace struct {
	Attributes *WorkspaceAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Links      *WorkspaceLinks      `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type       string               `form:"type" json:"type" xml:"type"`
}

// Validate validates the Workspace type instance.
func (ut *Workspace) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if !(ut.Type == "workspaces") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"workspaces"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a workspace. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type workspaceAttributes struct {
	// The URL of the codebase
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The workspace name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// Publicize creates WorkspaceAttributes from workspaceAttributes
func (ut *workspaceAttributes) Publicize() *WorkspaceAttributes {
	var pub WorkspaceAttributes
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a workspace. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type WorkspaceAttributes struct {
	// The URL of the codebase
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The workspace name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// workspaceEditLinks user type.
type workspaceEditLinks struct {
	Create *string `form:"create,omitempty" json:"create,omitempty" xml:"create,omitempty"`
}

// Publicize creates WorkspaceEditLinks from workspaceEditLinks
func (ut *workspaceEditLinks) Publicize() *WorkspaceEditLinks {
	var pub WorkspaceEditLinks
	if ut.Create != nil {
		pub.Create = ut.Create
	}
	return &pub
}

// WorkspaceEditLinks user type.
type WorkspaceEditLinks struct {
	Create *string `form:"create,omitempty" json:"create,omitempty" xml:"create,omitempty"`
}

// workspaceLinks user type.
type workspaceLinks struct {
	Open *string `form:"open,omitempty" json:"open,omitempty" xml:"open,omitempty"`
}

// Publicize creates WorkspaceLinks from workspaceLinks
func (ut *workspaceLinks) Publicize() *WorkspaceLinks {
	var pub WorkspaceLinks
	if ut.Open != nil {
		pub.Open = ut.Open
	}
	return &pub
}

// WorkspaceLinks user type.
type WorkspaceLinks struct {
	Open *string `form:"open,omitempty" json:"open,omitempty" xml:"open,omitempty"`
}

// workspaceOpenLinks user type.
type workspaceOpenLinks struct {
	Open *string `form:"open,omitempty" json:"open,omitempty" xml:"open,omitempty"`
}

// Publicize creates WorkspaceOpenLinks from workspaceOpenLinks
func (ut *workspaceOpenLinks) Publicize() *WorkspaceOpenLinks {
	var pub WorkspaceOpenLinks
	if ut.Open != nil {
		pub.Open = ut.Open
	}
	return &pub
}

// WorkspaceOpenLinks user type.
type WorkspaceOpenLinks struct {
	Open *string `form:"open,omitempty" json:"open,omitempty" xml:"open,omitempty"`
}

// A fieldDefinition aggregates a fieldType and additional field metadata
type fieldDefinition struct {
	// A description for the field
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// A label for the field that is shown in the UI
	Label    *string    `form:"label,omitempty" json:"label,omitempty" xml:"label,omitempty"`
	Required *bool      `form:"required,omitempty" json:"required,omitempty" xml:"required,omitempty"`
	Type     *fieldType `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the fieldDefinition type instance.
func (ut *fieldDefinition) Validate() (err error) {
	if ut.Required == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "required"))
	}
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Label == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "label"))
	}
	if ut.Description == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "description"))
	}
	if ut.Description != nil {
		if utf8.RuneCountInString(*ut.Description) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.description`, *ut.Description, utf8.RuneCountInString(*ut.Description), 1, true))
		}
	}
	if ut.Label != nil {
		if utf8.RuneCountInString(*ut.Label) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`response.label`, *ut.Label, utf8.RuneCountInString(*ut.Label), 1, true))
		}
	}
	if ut.Type != nil {
		if err2 := ut.Type.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates FieldDefinition from fieldDefinition
func (ut *fieldDefinition) Publicize() *FieldDefinition {
	var pub FieldDefinition
	if ut.Description != nil {
		pub.Description = *ut.Description
	}
	if ut.Label != nil {
		pub.Label = *ut.Label
	}
	if ut.Required != nil {
		pub.Required = *ut.Required
	}
	if ut.Type != nil {
		pub.Type = ut.Type.Publicize()
	}
	return &pub
}

// A fieldDefinition aggregates a fieldType and additional field metadata
type FieldDefinition struct {
	// A description for the field
	Description string `form:"description" json:"description" xml:"description"`
	// A label for the field that is shown in the UI
	Label    string     `form:"label" json:"label" xml:"label"`
	Required bool       `form:"required" json:"required" xml:"required"`
	Type     *FieldType `form:"type" json:"type" xml:"type"`
}

// Validate validates the FieldDefinition type instance.
func (ut *FieldDefinition) Validate() (err error) {

	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Label == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "label"))
	}
	if ut.Description == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "description"))
	}
	if utf8.RuneCountInString(ut.Description) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.description`, ut.Description, utf8.RuneCountInString(ut.Description), 1, true))
	}
	if utf8.RuneCountInString(ut.Label) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.label`, ut.Label, utf8.RuneCountInString(ut.Label), 1, true))
	}
	if ut.Type != nil {
		if err2 := ut.Type.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// A fieldType describes the values a particular field can hold
type fieldType struct {
	// The kind of type of the enumeration values for an enum type. Required for enum types. Must be a simple type, not  enum or list
	BaseType *string `form:"baseType,omitempty" json:"baseType,omitempty" xml:"baseType,omitempty"`
	// The kind of type of the individual elements for a list type. Required for list types. Must be a simple type, not  enum or list
	ComponentType *string `form:"componentType,omitempty" json:"componentType,omitempty" xml:"componentType,omitempty"`
	// The constant indicating the kind of type, for example 'string' or 'enum' or 'instant'
	Kind *string `form:"kind,omitempty" json:"kind,omitempty" xml:"kind,omitempty"`
	// The possible values for an enum type. The values must be of a type convertible to the base type
	Values []interface{} `form:"values,omitempty" json:"values,omitempty" xml:"values,omitempty"`
}

// Validate validates the fieldType type instance.
func (ut *fieldType) Validate() (err error) {
	if ut.Kind == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "kind"))
	}
	return
}

// Publicize creates FieldType from fieldType
func (ut *fieldType) Publicize() *FieldType {
	var pub FieldType
	if ut.BaseType != nil {
		pub.BaseType = ut.BaseType
	}
	if ut.ComponentType != nil {
		pub.ComponentType = ut.ComponentType
	}
	if ut.Kind != nil {
		pub.Kind = *ut.Kind
	}
	if ut.Values != nil {
		pub.Values = ut.Values
	}
	return &pub
}

// A fieldType describes the values a particular field can hold
type FieldType struct {
	// The kind of type of the enumeration values for an enum type. Required for enum types. Must be a simple type, not  enum or list
	BaseType *string `form:"baseType,omitempty" json:"baseType,omitempty" xml:"baseType,omitempty"`
	// The kind of type of the individual elements for a list type. Required for list types. Must be a simple type, not  enum or list
	ComponentType *string `form:"componentType,omitempty" json:"componentType,omitempty" xml:"componentType,omitempty"`
	// The constant indicating the kind of type, for example 'string' or 'enum' or 'instant'
	Kind string `form:"kind" json:"kind" xml:"kind"`
	// The possible values for an enum type. The values must be of a type convertible to the base type
	Values []interface{} `form:"values,omitempty" json:"values,omitempty" xml:"values,omitempty"`
}

// Validate validates the FieldType type instance.
func (ut *FieldType) Validate() (err error) {
	if ut.Kind == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "kind"))
	}
	return
}

// JSONAPI store for all the "attributes" of a filter. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type filterAttributes struct {
	// When the filter was created
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Query *string `form:"query,omitempty" json:"query,omitempty" xml:"query,omitempty"`
	// The Filter name
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Path to the topmost parent
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the filterAttributes type instance.
func (ut *filterAttributes) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Title == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "title"))
	}
	if ut.Description == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "description"))
	}
	if ut.Query == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "query"))
	}
	return
}

// Publicize creates FilterAttributes from filterAttributes
func (ut *filterAttributes) Publicize() *FilterAttributes {
	var pub FilterAttributes
	if ut.Description != nil {
		pub.Description = *ut.Description
	}
	if ut.Query != nil {
		pub.Query = *ut.Query
	}
	if ut.Title != nil {
		pub.Title = *ut.Title
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a filter. +See also see http://jsonapi.org/format/#document-resource-object-attributes
type FilterAttributes struct {
	// When the filter was created
	Description string `form:"description" json:"description" xml:"description"`
	// Version for optimistic concurrency control (optional during creating)
	Query string `form:"query" json:"query" xml:"query"`
	// The Filter name
	Title string `form:"title" json:"title" xml:"title"`
	// Path to the topmost parent
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the FilterAttributes type instance.
func (ut *FilterAttributes) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Title == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "title"))
	}
	if ut.Description == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "description"))
	}
	if ut.Query == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "query"))
	}
	return
}

// JSONAPI store for the data of a filter. See also http://jsonapi.org/format/#document-resource-object
type filters struct {
	Attributes *filterAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Type       *string           `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the filters type instance.
func (ut *filters) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "filters") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"filters"}))
		}
	}
	return
}

// Publicize creates Filters from filters
func (ut *filters) Publicize() *Filters {
	var pub Filters
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a filter. See also http://jsonapi.org/format/#document-resource-object
type Filters struct {
	Attributes *FilterAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Type       string            `form:"type" json:"type" xml:"type"`
}

// Validate validates the Filters type instance.
func (ut *Filters) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "filters") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"filters"}))
	}
	return
}

// pagingLinks user type.
type pagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}

// Publicize creates PagingLinks from pagingLinks
func (ut *pagingLinks) Publicize() *PagingLinks {
	var pub PagingLinks
	if ut.Filters != nil {
		pub.Filters = ut.Filters
	}
	if ut.First != nil {
		pub.First = ut.First
	}
	if ut.Last != nil {
		pub.Last = ut.Last
	}
	if ut.Next != nil {
		pub.Next = ut.Next
	}
	if ut.Prev != nil {
		pub.Prev = ut.Prev
	}
	return &pub
}

// PagingLinks user type.
type PagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}

// workItemListResponseMeta user type.
type workItemListResponseMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the workItemListResponseMeta type instance.
func (ut *workItemListResponseMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	return
}

// Publicize creates WorkItemListResponseMeta from workItemListResponseMeta
func (ut *workItemListResponseMeta) Publicize() *WorkItemListResponseMeta {
	var pub WorkItemListResponseMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// WorkItemListResponseMeta user type.
type WorkItemListResponseMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// Position represents the ID of the workitem above which the to-be-reordered workitem(s) should be placed
type workItemReorderPosition struct {
	// Direction of the place of the reorder workitem. Above should be used to place the reorder workitem(s) above workitem with id equal to position.id. Below should be used to place the reorder workitem(s) below workitem with id equal to position.id. Top places the reorder workitem(s) at the Topmost position of the list. Bottom places the reorder item(s) at the bottom of the list.
	Direction *string `form:"direction,omitempty" json:"direction,omitempty" xml:"direction,omitempty"`
	// ID of the workitem above which the to-be-reordered workitem(s) should be placed
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// Validate validates the workItemReorderPosition type instance.
func (ut *workItemReorderPosition) Validate() (err error) {
	if ut.Direction == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "direction"))
	}
	if ut.Direction != nil {
		if !(*ut.Direction == "above" || *ut.Direction == "below" || *ut.Direction == "top" || *ut.Direction == "bottom") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.direction`, *ut.Direction, []interface{}{"above", "below", "top", "bottom"}))
		}
	}
	return
}

// Publicize creates WorkItemReorderPosition from workItemReorderPosition
func (ut *workItemReorderPosition) Publicize() *WorkItemReorderPosition {
	var pub WorkItemReorderPosition
	if ut.Direction != nil {
		pub.Direction = *ut.Direction
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	return &pub
}

// Position represents the ID of the workitem above which the to-be-reordered workitem(s) should be placed
type WorkItemReorderPosition struct {
	// Direction of the place of the reorder workitem. Above should be used to place the reorder workitem(s) above workitem with id equal to position.id. Below should be used to place the reorder workitem(s) below workitem with id equal to position.id. Top places the reorder workitem(s) at the Topmost position of the list. Bottom places the reorder item(s) at the bottom of the list.
	Direction string `form:"direction" json:"direction" xml:"direction"`
	// ID of the workitem above which the to-be-reordered workitem(s) should be placed
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// Validate validates the WorkItemReorderPosition type instance.
func (ut *WorkItemReorderPosition) Validate() (err error) {
	if ut.Direction == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "direction"))
	}
	if !(ut.Direction == "above" || ut.Direction == "below" || ut.Direction == "top" || ut.Direction == "bottom") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.direction`, ut.Direction, []interface{}{"above", "below", "top", "bottom"}))
	}
	return
}

// workItemTypeGroupLinks user type.
type workItemTypeGroupLinks struct {
	Self *string `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Validate validates the workItemTypeGroupLinks type instance.
func (ut *workItemTypeGroupLinks) Validate() (err error) {
	if ut.Self == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}

// Publicize creates WorkItemTypeGroupLinks from workItemTypeGroupLinks
func (ut *workItemTypeGroupLinks) Publicize() *WorkItemTypeGroupLinks {
	var pub WorkItemTypeGroupLinks
	if ut.Self != nil {
		pub.Self = *ut.Self
	}
	return &pub
}

// WorkItemTypeGroupLinks user type.
type WorkItemTypeGroupLinks struct {
	Self string `form:"self" json:"self" xml:"self"`
}

// Validate validates the WorkItemTypeGroupLinks type instance.
func (ut *WorkItemTypeGroupLinks) Validate() (err error) {
	if ut.Self == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "self"))
	}
	return
}
